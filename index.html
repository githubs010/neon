<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Strategy: Titanium</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-color: #050510;
            --p1-color: #00f2ff; /* Cyan */
            --p1-glow: rgba(0, 242, 255, 0.6);
            --p2-color: #ff0055; /* Red */
            --p2-glow: rgba(255, 0, 85, 0.6);
            --panel-bg: rgba(20, 20, 30, 0.95);
        }

        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }

        body {
            background-color: var(--bg-color);
            background-image: radial-gradient(circle at 50% 50%, #1a1a2e 0%, #000000 100%);
            color: white;
            font-family: 'Rajdhani', sans-serif;
            margin: 0;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* --- RESPONSIVE LAYOUT --- */
        .main-layout {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%; height: 100%;
        }
        .game-area {
            width: 95vw; height: 95vw;
            max-width: 500px; max-height: 500px;
            position: relative;
        }
        .hud-area {
            width: 100%; padding: 15px;
            background: var(--panel-bg);
            border-top: 2px solid #333;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            flex-grow: 1; z-index: 10;
        }

        @media (min-width: 800px) and (orientation: landscape) {
            .main-layout { flex-direction: row; gap: 40px; }
            .game-area { width: 80vh; height: 80vh; max-width: 800px; border: 2px solid #333; border-radius: 12px; background: #000; }
            .hud-area { width: 320px; height: 80vh; border-top: none; border-left: 2px solid #333; border-radius: 12px; flex-grow: 0; background: rgba(0,0,0,0.6); }
        }

        /* --- UI ELEMENTS --- */
        canvas { width: 100%; height: 100%; border-radius: 8px; display: block; }
        .targeting { cursor: crosshair; }

        .status-title { font-family: 'Orbitron'; font-size: 1.8rem; font-weight: bold; margin-bottom: 5px; text-align: center; }
        .status-sub { font-size: 1rem; opacity: 0.7; text-align: center; margin-bottom: 20px; }
        .p1-turn { color: var(--p1-color); text-shadow: 0 0 15px var(--p1-glow); }
        .p2-turn { color: var(--p2-color); text-shadow: 0 0 15px var(--p2-glow); }
        .alert-mode { color: #ffe600; text-shadow: 0 0 20px #ffe600; animation: pulse 0.8s infinite; }
        @keyframes pulse { 50% { opacity: 0.5; } }

        .score-board { display: flex; gap: 20px; margin-bottom: 10px; font-family: 'Orbitron'; font-size: 1.2rem; }
        .score-p1 { color: var(--p1-color); }
        .score-p2 { color: var(--p2-color); }

        .btn {
            background: transparent; border: 1px solid #555; color: #aaa;
            padding: 10px 30px; font-family: 'Orbitron'; cursor: pointer;
            transition: 0.2s; margin-top: 5px;
        }
        .btn:hover { border-color: white; color: white; background: rgba(255,255,255,0.1); }

        /* --- OVERLAYS & MENUS --- */
        .overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 100;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            backdrop-filter: blur(8px);
        }
        
        h1 { font-family: 'Orbitron'; font-size: 2.5rem; text-align: center; margin-bottom: 20px; text-shadow: 0 0 20px rgba(255,255,255,0.3); }

        .menu-btn {
            width: 280px; padding: 15px; margin: 10px;
            background: transparent; border: 2px solid var(--p1-color); color: var(--p1-color);
            font-family: 'Orbitron'; font-size: 1.1rem; cursor: pointer; text-align: center;
            box-shadow: 0 0 15px var(--p1-glow);
        }
        .menu-btn:hover { background: var(--p1-color); color: #000; }
        .menu-btn.cpu { border-color: #fff; color: #fff; box-shadow: 0 0 15px rgba(255,255,255,0.3); }

        /* Difficulty Slider */
        .slider-container { width: 280px; margin: 20px 0; text-align: center; }
        .slider-label { font-family: 'Orbitron'; margin-bottom: 10px; display: block; color: var(--p2-color); }
        input[type=range] { width: 100%; accent-color: var(--p2-color); }

        /* COIN FLIP UI */
        .coin {
            width: 140px; height: 140px; border-radius: 50%;
            border: 6px solid #fff; background: #222;
            display: flex; justify-content: center; align-items: center;
            font-size: 2rem; font-family: 'Orbitron';
            box-shadow: 0 0 40px rgba(255,255,255,0.2);
            cursor: pointer; margin-bottom: 20px; transition: transform 0.5s;
        }
        .coin.flip { animation: spin 0.2s infinite linear; }
        @keyframes spin { 0% { transform: rotateY(0deg); } 100% { transform: rotateY(360deg); } }
        .coin.win { border-color: #0f0; color: #0f0; box-shadow: 0 0 50px #0f0; background: #002200; }
        .coin.lose { border-color: #f00; color: #f00; box-shadow: 0 0 50px #f00; background: #220000; }

    </style>
</head>
<body>

    <div id="main-menu" class="overlay">
        <h1>NEON STRATEGY<br><span style="font-size:1rem; letter-spacing:4px; opacity:0.8; color:#aaa;">TITANIUM EDITION</span></h1>
        
        <button class="menu-btn" onclick="startGame('PVP')">PLAYER vs PLAYER</button>
        
        <div class="slider-container">
            <label class="slider-label">CPU POWER: <span id="cpu-val">5</span>/10</label>
            <input type="range" id="cpu-slider" min="1" max="10" value="5" oninput="document.getElementById('cpu-val').innerText=this.value">
        </div>
        <button class="menu-btn cpu" onclick="startGame('PVC')">VS CPU</button>
    </div>

    <div id="coin-overlay" class="overlay" style="display:none;">
        <div id="coin-visual" class="coin" onclick="startFlip()">FLIP</div>
        <div id="coin-msg" style="text-align:center; font-family:'Orbitron'; font-size:1.3rem;">NO MOVES!<br><span style="font-size:0.9rem; color:#888">Flip to Kill & Clear Space</span></div>
    </div>

    <div class="main-layout">
        <div class="game-area">
            <canvas id="gameBoard"></canvas>
        </div>
        <div class="hud-area">
            <div class="score-board">
                <div class="score-p1">P1: <span id="s1">12</span></div>
                <div class="score-p2">OPP: <span id="s2">12</span></div>
            </div>
            <div class="status-box">
                <div id="status-t" class="status-title p1-turn">YOUR TURN</div>
                <div id="status-sub" class="status-sub">Place Unit</div>
            </div>
            <button class="btn" onclick="resetGame()">RESTART</button>
            <button class="btn" style="border:none; font-size:0.8rem; margin-top:0;" onclick="location.reload()">MENU</button>
        </div>
    </div>

<script>
/** NEON STRATEGY TITANIUM ENGINE **/

// --- CONFIG ---
const P1_COLOR = '#00f2ff';
const P2_COLOR = '#ff0055';

// --- STATE ---
let mode = 'PVC';
let difficulty = 5; // 1-10
let turn = 1; 
let phase = 'PLACING'; 
let board = [];
let p1Left=12, p2Left=12;
let p1Board=0, p2Board=0;
let selectedId = -1;

// Board Geometry
const rawPoints = [
    {x:0.1,y:0.1},{x:0.5,y:0.1},{x:0.9,y:0.1}, {x:0.9,y:0.5},{x:0.9,y:0.9},{x:0.5,y:0.9}, {x:0.1,y:0.9},{x:0.1,y:0.5},
    {x:0.25,y:0.25},{x:0.5,y:0.25},{x:0.75,y:0.25}, {x:0.75,y:0.5},{x:0.75,y:0.75},{x:0.5,y:0.75}, {x:0.25,y:0.75},{x:0.25,y:0.5},
    {x:0.4,y:0.4},{x:0.5,y:0.4},{x:0.6,y:0.4}, {x:0.6,y:0.5},{x:0.6,y:0.6},{x:0.5,y:0.6}, {x:0.4,y:0.6},{x:0.4,y:0.5}
];
const adj = [
    [1,7,8],[0,2,9],[1,3,10],[2,4,11],[3,5,12],[4,6,13],[5,7,14],[0,6,15],
    [0,9,15,16],[1,8,10,17],[2,9,11,18],[3,10,12,19],[4,11,13,20],[5,12,14,21],[6,13,15,22],[7,8,14,23],
    [8,17,23],[9,16,18],[10,17,19],[11,18,20],[12,19,21],[13,20,22],[14,21,23],[15,16,22]
];
const mills = [
    [0,1,2],[2,3,4],[4,5,6],[6,7,0], [8,9,10],[10,11,12],[12,13,14],[14,15,8],
    [16,17,18],[18,19,20],[20,21,22],[22,23,16], [1,9,17],[3,11,19],[5,13,21],[7,15,23],
    [0,8,16],[2,10,18],[4,12,20],[6,14,22]
];

function startGame(m) {
    mode = m;
    difficulty = parseInt(document.getElementById('cpu-slider').value);
    document.getElementById('main-menu').style.display='none';
    resetGame();
}

function resetGame() {
    board = rawPoints.map((p,i)=>({id:i, owner:0}));
    turn = 1; phase = 'PLACING';
    p1Left=12; p2Left=12; p1Board=0; p2Board=0;
    selectedId=-1;
    document.getElementById('coin-overlay').style.display='none';
    resize(); updateUI();
}

// --- INPUT LOGIC ---
function handleClick(idx) {
    if(mode==='PVC' && turn===2) return;
    if(phase==='TRAPPED' || phase==='GAME_OVER') return;

    if(phase==='PLACING') {
        if(board[idx].owner!==0) return;
        move(idx, turn, 'PLACE');
    }
    else if(phase==='MOVING') {
        if(board[idx].owner===turn) { selectedId=idx; updateUI(); }
        else if(selectedId!==-1 && board[idx].owner===0 && adj[selectedId].includes(idx)) {
            move(idx, turn, 'MOVE', selectedId);
        }
    }
    else if(phase==='REMOVING') {
        const enemy = turn===1?2:1;
        if(board[idx].owner===enemy) {
            if(isProtected(idx, enemy)) { alert("Protected by Mill!"); return; }
            kill(idx, enemy);
        }
    }
}

function move(to, ply, type, from) {
    board[to].owner = ply;
    if(type==='PLACE') { if(ply===1)p1Left--; else p2Left--; if(ply===1)p1Board++; else p2Board++; }
    if(type==='MOVE') { board[from].owner=0; selectedId=-1; }

    if(checkMill(to, ply)) {
        phase='REMOVING';
        if(mode==='PVC' && ply===2) setTimeout(aiKill, 800);
        else updateUI(true, "TARGET LOCKED", "Shoot Enemy to Clear Space");
    } else {
        endTurn();
    }
}

function kill(idx, owner) {
    board[idx].owner = 0;
    if(owner===2) p2Board--; else p1Board--;
    
    // Win Check
    if(p1Left===0 && p2Left===0) {
        if(p2Board<3) { gameOver(1); return; }
        if(p1Board<3) { gameOver(2); return; }
    }
    
    phase = (p1Left>0||p2Left>0)?'PLACING':'MOVING';
    endTurn();
}

function endTurn() {
    if(phase==='GAME_OVER') return;
    turn = (turn===1)?2:1;
    
    // DEADLOCK CHECK: If current player has 0 moves
    if(phase==='MOVING' && countMoves(turn)===0) {
        phase='TRAPPED'; 
        showCoinFlip(turn); 
        return;
    }

    updateUI();
    if(mode==='PVC' && turn===2) setTimeout(aiMove, 600);
}

// --- COIN FLIP MECHANIC ---
function showCoinFlip(who) {
    const ov = document.getElementById('coin-overlay');
    const msg = document.getElementById('coin-msg');
    const coin = document.getElementById('coin-visual');
    
    ov.style.display = 'flex';
    coin.className = 'coin'; coin.innerText = "FLIP";
    
    if(mode==='PVC' && who===2) {
        msg.innerHTML = "CPU TRAPPED!<br>Flipping to break lock...";
        coin.onclick = null;
        setTimeout(flip, 1500);
    } else {
        msg.innerHTML = "YOU ARE TRAPPED!<br>Flip to Kill & Clear Space";
        coin.onclick = flip;
    }
}

function flip() {
    const coin = document.getElementById('coin-visual');
    const msg = document.getElementById('coin-msg');
    coin.className = 'coin flip'; coin.innerText = "";
    
    setTimeout(()=>{
        let win = Math.random()>0.5;
        coin.className = 'coin'; 
        coin.style.borderColor = win?'#0f0':'#f00';
        coin.style.color = win?'#0f0':'#f00';
        coin.innerText = win?"WIN":"LOSE";
        
        if(win) {
            msg.innerHTML = "SUCCESS!<br><span style='color:#0f0'>Kill enemy to make space!</span>";
            setTimeout(()=>{
                document.getElementById('coin-overlay').style.display='none';
                phase='REMOVING';
                if(turn===2 && mode==='PVC') aiKill(); 
                else updateUI(true, "TARGET LOCKED", "Shoot to Free Yourself!"); 
            }, 1500);
        } else {
            msg.innerHTML = "FAILURE<br><span style='color:#f00'>Self Destruct...</span>";
            setTimeout(()=>{ gameOver(turn===1?2:1); }, 1500);
        }
    }, 1500);
}

// --- SCALABLE AI (1-10) ---
function aiMove() {
    if(phase==='TRAPPED') return;

    let moves = getValidMoves(2);
    if(moves.length===0) return; 

    // Level 1-3: Random / Basic
    if(difficulty <= 3) {
        let m = moves[Math.floor(Math.random()*moves.length)];
        // Simple Heuristic for Level 3
        if(difficulty === 3) {
            for(let mv of moves) {
                // Take win if available
                let prev = board[mv.to].owner;
                board[mv.to].owner=2; if(mv.type==='MOVE') board[mv.from].owner=0;
                if(checkMill(mv.to, 2)) { m = mv; break; }
                board[mv.to].owner=prev; if(mv.type==='MOVE') board[mv.from].owner=2;
            }
        }
        move(m.to, 2, m.type, m.from);
        return;
    }

    // Level 4-10: Minimax with scaling depth
    let depth = 1; // Default Level 4
    if(difficulty >= 5 && difficulty <= 7) depth = 2;
    if(difficulty >= 8 && difficulty <= 9) depth = 3;
    if(difficulty === 10) depth = 4;

    let bestScore = -Infinity;
    let bestMove = moves[0];

    for(let m of moves) {
        let prev = board[m.to].owner;
        board[m.to].owner=2; if(m.type==='MOVE') board[m.from].owner=0;
        let score = minimax(depth, false, -Infinity, Infinity);
        board[m.to].owner=prev; if(m.type==='MOVE') board[m.from].owner=2;

        // Add randomness for lower levels
        if(difficulty < 8) score += Math.random() * 20;

        if(score > bestScore) { bestScore = score; bestMove = m; }
    }
    move(bestMove.to, 2, bestMove.type, bestMove.from);
}

function minimax(d, isMax, alpha, beta) {
    if(d===0) return evaluate();
    let ply = isMax ? 2 : 1;
    let moves = getValidMoves(ply);
    if(moves.length===0) return isMax ? -5000 : 5000;

    if(isMax) {
        let maxEval = -Infinity;
        for(let m of moves) {
            let prev = board[m.to].owner;
            board[m.to].owner=2; if(m.type==='MOVE') board[m.from].owner=0;
            let eval = minimax(d-1, false, alpha, beta);
            board[m.to].owner=prev; if(m.type==='MOVE') board[m.from].owner=2;
            maxEval = Math.max(maxEval, eval);
            alpha = Math.max(alpha, eval);
            if(beta <= alpha) break;
        }
        return maxEval;
    } else {
        let minEval = Infinity;
        for(let m of moves) {
            let prev = board[m.to].owner;
            board[m.to].owner=1; if(m.type==='MOVE') board[m.from].owner=0;
            let eval = minimax(d-1, true, alpha, beta);
            board[m.to].owner=prev; if(m.type==='MOVE') board[m.from].owner=1;
            minEval = Math.min(minEval, eval);
            beta = Math.min(beta, eval);
            if(beta <= alpha) break;
        }
        return minEval;
    }
}

function evaluate() {
    let score = (p2Board - p1Board) * 100;
    score += countMills(2) * 50;
    score -= countMills(1) * 50;
    score += countBlockedMills(2) * 30; 
    return score;
}

function aiKill() {
    let targets = board.filter(p=>p.owner===1 && !isProtected(p.id, 1));
    if(targets.length > 0) {
        // Smart kill for high levels
        if(difficulty > 5) targets.sort((a,b) => countAdj(b.id,1) - countAdj(a.id,1));
        kill(targets[0].id, 1);
    } else {
        phase=(p1Left>0||p2Left>0)?'PLACING':'MOVING'; endTurn();
    }
}

// --- UTILS ---
function getValidMoves(ply) {
    let moves = [];
    if(phase==='PLACING') {
        board.forEach(p=>{if(p.owner===0)moves.push({to:p.id, type:'PLACE'})});
    } else {
        board.forEach(p=>{
            if(p.owner===ply) adj[p.id].forEach(n=>{if(board[n].owner===0)moves.push({from:p.id, to:n, type:'MOVE'})});
        });
    }
    return moves;
}
function checkMill(idx, ply) {
    for(let m of mills) if(m.includes(idx) && board[m[0]].owner===ply && board[m[1]].owner===ply && board[m[2]].owner===ply) return true;
    return false;
}
function isProtected(idx, ply) {
    if(!checkMill(idx, ply)) return false;
    let all = board.filter(p=>p.owner===ply);
    return !all.every(p=>checkMill(p.id, ply));
}
function countMills(ply) {
    let c=0; mills.forEach(m=>{if(board[m[0]].owner===ply && board[m[1]].owner===ply && board[m[2]].owner===ply) c++}); return c;
}
function countBlockedMills(ply) {
    let opp = ply===1?2:1;
    let c=0; mills.forEach(m=>{
        let o=0, me=0; m.forEach(i=>{if(board[i].owner===opp)o++; else if(board[i].owner===ply)me++;});
        if(o===2 && me===1) c++;
    });
    return c;
}
function countMoves(ply) { return getValidMoves(ply).length; }
function countAdj(idx, ply) { return adj[idx].filter(n=>board[n].owner===ply).length; }

function gameOver(w) {
    document.getElementById('coin-overlay').style.display='none';
    phase='GAME_OVER';
    updateUI(true, (w===1?"PLAYER 1":"CPU") + " WINS!", "Game Over");
}

// --- RENDER ---
const cvs = document.getElementById('gameBoard');
const ctx = cvs.getContext('2d');
let bs = 0;

function resize() {
    const rect = cvs.parentElement.getBoundingClientRect();
    bs = rect.width; cvs.width = bs; cvs.height = bs;
    draw();
}
window.onresize = resize;

function draw() {
    ctx.clearRect(0,0,bs,bs);
    ctx.strokeStyle = '#333'; ctx.lineWidth=bs*0.01; ctx.beginPath();
    board.forEach(p=>adj[p.id].forEach(n=>{if(n>p.id){
        ctx.moveTo(rawPoints[p.id].x*bs, rawPoints[p.id].y*bs);
        ctx.lineTo(rawPoints[n].x*bs, rawPoints[n].y*bs);
    }}));
    ctx.stroke();

    board.forEach(p=>{
        let x = rawPoints[p.id].x*bs, y=rawPoints[p.id].y*bs;
        if(p.owner===0) {
            ctx.fillStyle='#222'; ctx.beginPath(); ctx.arc(x,y,bs*0.015,0,Math.PI*2); ctx.fill();
        } else {
            let col = p.owner===1?P1_COLOR:P2_COLOR;
            ctx.fillStyle=col; ctx.shadowBlur=15; ctx.shadowColor=col;
            ctx.beginPath(); ctx.arc(x,y,bs*0.035,0,Math.PI*2); ctx.fill(); ctx.shadowBlur=0;
            if(phase==='REMOVING' && turn===1 && p.owner===2 && !isProtected(p.id,2)) {
                ctx.strokeStyle='#fff'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(x,y,bs*0.05,0,Math.PI*2); ctx.stroke();
            }
            if(p.id===selectedId) {
                ctx.strokeStyle='#fff'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(x,y,bs*0.055,0,Math.PI*2); ctx.stroke();
            }
        }
    });
}

function updateUI(alert, t, sub) {
    const st = document.getElementById('status-t');
    const ss = document.getElementById('status-sub');
    document.getElementById('s1').innerText = phase==='PLACING'?p1Left:p1Board;
    document.getElementById('s2').innerText = phase==='PLACING'?p2Left:p2Board;
    
    if(t) {
        st.innerText = t; ss.innerText = sub;
        st.className = alert?"status-title alert-mode":"status-title";
    } else {
        let name = turn===1?"PLAYER 1":(mode==='PVC'?"CPU":"PLAYER 2");
        st.innerText = name + " TURN";
        st.className = turn===1?"status-title p1-turn":"status-title p2-turn";
        ss.innerText = phase==='PLACING'?"Place Unit":"Move Unit";
    }
    
    if(phase==='REMOVING' && turn===1) cvs.classList.add('targeting');
    else cvs.classList.remove('targeting');
    draw();
}

cvs.addEventListener('mousedown', e=>input(e.clientX, e.clientY));
cvs.addEventListener('touchstart', e=>{e.preventDefault(); input(e.touches[0].clientX, e.touches[0].clientY)}, {passive:false});

function input(cx, cy) {
    let r = cvs.getBoundingClientRect();
    let x = cx-r.left, y=cy-r.top;
    let scaleX = cvs.width / r.width;
    let scaleY = cvs.height / r.height;
    for(let i=0; i<24; i++) {
        let px = rawPoints[i].x*bs, py=rawPoints[i].y*bs;
        if(Math.hypot((x*scaleX)-px, (y*scaleY)-py) < bs*0.08) { handleClick(i); break; }
    }
}
</script>
</body>
</html>

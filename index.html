<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#000000">
    <title>Neon Strategy: COIN FLIP EDITION</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-color: #050510;
            --p1-color: #00f2ff; /* Player */
            --p1-glow: rgba(0, 242, 255, 0.6);
            --p2-color: #ff0055; /* AI */
            --p2-glow: rgba(255, 0, 85, 0.6);
        }

        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }

        body {
            font-family: 'Rajdhani', sans-serif;
            background-color: var(--bg-color);
            background-image: radial-gradient(circle at 50% 50%, #1a1a2e 0%, #000000 100%);
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            padding-top: 10px;
        }

        h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.8rem;
            margin: 5px 0 15px 0;
            color: #fff;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        }

        .game-wrapper {
            width: 95%; max-width: 500px;
            aspect-ratio: 1 / 1;
            position: relative;
            margin-bottom: 10px;
        }

        .game-container {
            width: 100%; height: 100%;
            box-shadow: 0 0 50px rgba(255, 0, 85, 0.2);
            border-radius: 12px;
            padding: 4px;
            background: linear-gradient(135deg, #111, #222);
            border: 1px solid #333;
            position: relative;
        }

        canvas {
            background-color: #08080c;
            border-radius: 8px;
            display: block;
            width: 100%; height: 100%;
            touch-action: none;
        }

        /* COIN FLIP OVERLAY */
        #coin-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            border-radius: 8px;
            backdrop-filter: blur(5px);
        }

        .coin {
            width: 120px; height: 120px;
            border-radius: 50%;
            border: 8px solid #fff;
            display: flex; justify-content: center; align-items: center;
            font-size: 2rem; font-family: 'Orbitron'; font-weight: bold;
            box-shadow: 0 0 50px rgba(255,255,255,0.5);
            cursor: pointer;
            transition: transform 0.1s;
            background: #222;
        }
        
        .coin.flipping { animation: spin 0.2s infinite linear; }
        @keyframes spin { 0% { transform: rotateY(0deg); } 100% { transform: rotateY(360deg); } }

        .coin-p1 { background: var(--p1-color); color: #000; box-shadow: 0 0 40px var(--p1-glow); border-color: var(--p1-color); }
        .coin-p2 { background: var(--p2-color); color: #000; box-shadow: 0 0 40px var(--p2-glow); border-color: var(--p2-color); }

        .coin-msg {
            margin-top: 20px; font-size: 1.2rem; text-align: center; color: #fff; text-transform: uppercase; letter-spacing: 2px;
        }

        /* HUD */
        .hud-panel {
            background: rgba(10, 10, 20, 0.95);
            border-top: 2px solid var(--p2-color);
            padding: 15px;
            border-radius: 20px 20px 0 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            flex-grow: 1;
        }

        .status-text { font-size: 1.5rem; font-weight: 700; text-align: center; margin-bottom: 5px; }
        .sub-text { font-size: 0.9rem; opacity: 0.6; margin-bottom: 15px; font-family: 'Orbitron'; }
        
        .status-p1 { color: var(--p1-color); text-shadow: 0 0 10px var(--p1-glow); }
        .status-p2 { color: var(--p2-color); text-shadow: 0 0 10px var(--p2-glow); }
        .status-alert { color: #ffe600; text-shadow: 0 0 10px #ffe600; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0.5; } }

        .btn {
            background: var(--p2-color);
            color: white; border: none; padding: 12px 40px;
            font-family: 'Orbitron', sans-serif; font-size: 1rem;
            border-radius: 4px; cursor: pointer;
            box-shadow: 0 0 15px var(--p2-glow);
        }
    </style>
</head>
<body>

    <h1>COIN FLIP BREAKER</h1>

    <div class="game-wrapper">
        <div class="game-container">
            <canvas id="gameBoard"></canvas>
            
            <div id="coin-overlay">
                <div style="color:#ffe600; font-size:1.2rem; margin-bottom:20px; font-family:'Orbitron'">TRAPPED!</div>
                <div id="the-coin" class="coin" onclick="flipCoin()">FLIP</div>
                <div id="coin-text" class="coin-msg">Tap to Flip for your Life</div>
            </div>

        </div>
    </div>

    <div class="hud-panel">
        <div class="status-text status-p1" id="status">YOUR TURN</div>
        <div class="sub-text" id="sub-status">Place your unit</div>
        <button class="btn" onclick="location.reload()">RESTART</button>
    </div>

<script>
// --- CONFIGURATION ---
const P1_COLOR = '#00f2ff';
const P2_COLOR = '#ff0055';
const P1_GLOW = 'rgba(0, 242, 255, 0.6)';
const P2_GLOW = 'rgba(255, 0, 85, 0.6)';

// Game State
let board = [];
let turn = 1; // 1=Player, 2=AI
let phase = 'PLACING'; // PLACING, MOVING, REMOVING, LOCKED_FLIP, GAME_OVER
let p1Left = 12, p2Left = 12;
let p1Board = 0, p2Board = 0;
let selectedId = -1;
let aiProcessing = false;

// 24 Points Data
const rawPoints = [
    {x:0.1,y:0.1},{x:0.5,y:0.1},{x:0.9,y:0.1}, {x:0.9,y:0.5},{x:0.9,y:0.9},{x:0.5,y:0.9}, {x:0.1,y:0.9},{x:0.1,y:0.5},
    {x:0.25,y:0.25},{x:0.5,y:0.25},{x:0.75,y:0.25}, {x:0.75,y:0.5},{x:0.75,y:0.75},{x:0.5,y:0.75}, {x:0.25,y:0.75},{x:0.25,y:0.5},
    {x:0.4,y:0.4},{x:0.5,y:0.4},{x:0.6,y:0.4}, {x:0.6,y:0.5},{x:0.6,y:0.6},{x:0.5,y:0.6}, {x:0.4,y:0.6},{x:0.4,y:0.5}
];
const adj = [
    [1,7,8],[0,2,9],[1,3,10],[2,4,11],[3,5,12],[4,6,13],[5,7,14],[0,6,15],
    [0,9,15,16],[1,8,10,17],[2,9,11,18],[3,10,12,19],[4,11,13,20],[5,12,14,21],[6,13,15,22],[7,8,14,23],
    [8,17,23],[9,16,18],[10,17,19],[11,18,20],[12,19,21],[13,20,22],[14,21,23],[15,16,22]
];
const mills = [
    [0,1,2],[2,3,4],[4,5,6],[6,7,0], [8,9,10],[10,11,12],[12,13,14],[14,15,8],
    [16,17,18],[18,19,20],[20,21,22],[22,23,16], [1,9,17],[3,11,19],[5,13,21],[7,15,23],
    [0,8,16],[2,10,18],[4,12,20],[6,14,22]
];

function initGame() {
    board = rawPoints.map((p,i) => ({id:i, owner:0}));
    turn = 1; phase = 'PLACING';
    p1Left=12; p2Left=12; p1Board=0; p2Board=0;
    selectedId=-1; aiProcessing=false;
    resize(); updateUI();
}

// --- CORE LOGIC ---
function handleInput(idx) {
    if(turn === 2 || aiProcessing || phase === 'GAME_OVER' || phase === 'LOCKED_FLIP') return;

    if(phase === 'PLACING') {
        if(board[idx].owner !== 0) return;
        makeMove(idx, 1, 'PLACE');
    }
    else if(phase === 'MOVING') {
        if(board[idx].owner === 1) { selectedId = idx; updateUI(); } 
        else if(selectedId !== -1 && board[idx].owner === 0 && adj[selectedId].includes(idx)) {
            makeMove(idx, 1, 'MOVE', selectedId);
        }
    }
    else if(phase === 'REMOVING') {
        if(board[idx].owner === 2) {
            if(isProtected(idx, 2)) { updateUI(true, "PROTECTED", "Cannot kill safe unit"); return; }
            removeUnit(idx, 2);
        }
    }
}

function makeMove(targetIdx, player, type, fromIdx) {
    if(type === 'PLACE') {
        board[targetIdx].owner = player;
        if(player===1) { p1Left--; p1Board++; } else { p2Left--; p2Board++; }
    } else {
        board[targetIdx].owner = player;
        board[fromIdx].owner = 0;
        selectedId = -1;
    }

    if(checkMill(targetIdx, player)) {
        phase = 'REMOVING';
        if(player===1) updateUI(true, "KILL MODE", "Destroy an Enemy!");
        else setTimeout(aiKill, 800);
    } else {
        endTurn();
    }
}

function endTurn() {
    if(phase === 'GAME_OVER') return;
    
    // Switch Turn
    turn = (turn===1) ? 2 : 1;
    
    // CHECK FOR TRAP (The new Logic)
    if(phase === 'MOVING') {
        if(countValidMoves(turn) === 0) {
            triggerCoinFlip(turn);
            return;
        }
    }

    updateUI();
    
    if(turn === 2) {
        aiProcessing = true;
        setTimeout(() => {
            if(phase === 'LOCKED_FLIP') {
                // AI automatically flips
                flipCoin(); 
            } else {
                const move = getBestAIMove();
                if(move) {
                    if(phase==='PLACING') makeMove(move.to, 2, 'PLACE');
                    else makeMove(move.to, 2, 'MOVE', move.from);
                }
            }
            aiProcessing = false;
        }, 600);
    }
}

// --- COIN FLIP MECHANIC ---
function triggerCoinFlip(player) {
    phase = 'LOCKED_FLIP';
    const overlay = document.getElementById('coin-overlay');
    const coin = document.getElementById('the-coin');
    const msg = document.getElementById('coin-text');
    
    overlay.style.display = 'flex';
    coin.className = 'coin';
    coin.innerText = "FLIP";
    
    if(player === 1) {
        msg.innerText = "You are trapped! Flip to survive.";
        aiProcessing = false; // Allow player input
    } else {
        msg.innerText = "AI is trapped! AI is flipping...";
    }
}

function flipCoin() {
    if(phase !== 'LOCKED_FLIP') return;
    
    const coin = document.getElementById('the-coin');
    const msg = document.getElementById('coin-text');
    
    coin.className = 'coin flipping';
    msg.innerText = "Flipping...";

    // 2 Seconds Spin
    setTimeout(() => {
        // 50/50 Chance
        const win = Math.random() > 0.5;
        const player = turn; // Who is flipping?

        coin.className = 'coin'; // Stop spin
        
        if(win) {
            // SUCCESS
            coin.classList.add(player===1 ? 'coin-p1' : 'coin-p2');
            coin.innerText = "WIN";
            msg.innerText = "COIN MATCH! KILL GRANTED!";
            
            setTimeout(() => {
                document.getElementById('coin-overlay').style.display = 'none';
                phase = 'REMOVING';
                if(player === 1) updateUI(true, "LUCKY BREAK", "Destroy an Enemy!");
                else {
                    updateUI(true, "AI SAVED", "AI won the flip!");
                    setTimeout(aiKill, 1000);
                }
            }, 1500);

        } else {
            // FAIL
            const enemy = player===1 ? 2 : 1;
            coin.classList.add(enemy===1 ? 'coin-p1' : 'coin-p2');
            coin.innerText = "LOSS";
            msg.innerText = "BAD LUCK. GAME OVER.";
            
            setTimeout(() => {
                document.getElementById('coin-overlay').style.display = 'none';
                gameOver(enemy); // Enemy wins
            }, 2000);
        }
    }, 1500);
}

// --- AI LOGIC (Simplified for stability) ---
function getBestAIMove() {
    let moves = [];
    if(phase==='PLACING') {
        board.forEach(p => { if(p.owner===0) moves.push({to:p.id}); });
    } else {
        board.forEach(p => {
            if(p.owner===2) adj[p.id].forEach(n => { if(board[n].owner===0) moves.push({from:p.id, to:n}); });
        });
    }
    
    // Pick best move (Prioritize Mills)
    for(let m of moves) {
        // Sim
        let prev = board[m.to].owner;
        board[m.to].owner = 2;
        if(m.from !== undefined) board[m.from].owner = 0;
        
        let win = checkMill(m.to, 2);
        
        // Undo
        board[m.to].owner = prev;
        if(m.from !== undefined) board[m.from].owner = 2;
        
        if(win) return m;
    }
    
    // Random fallback
    return moves[Math.floor(Math.random() * moves.length)];
}

function aiKill() {
    const targets = board.filter(p => p.owner===1 && !isProtected(p.id, 1));
    if(targets.length > 0) {
        removeUnit(targets[0].id, 1);
    } else {
        // Should catch the all-protected edge case, but standard rules usually force kill anyway. 
        // We'll skip kill if all protected.
        phase = (p1Left>0||p2Left>0)?'PLACING':'MOVING';
        endTurn();
    }
}

// --- HELPERS ---
function countValidMoves(ply) {
    if(phase === 'PLACING') return 1; // Always can place if spots left
    let moves = 0;
    board.filter(p=>p.owner===ply).forEach(u => {
        adj[u.id].forEach(n => { if(board[n].owner===0) moves++; });
    });
    return moves;
}

function checkMill(idx, ply) {
    for(let m of mills) {
        if(m.includes(idx) && board[m[0]].owner===ply && board[m[1]].owner===ply && board[m[2]].owner===ply) return true;
    }
    return false;
}

function isProtected(idx, ply) {
    if(!checkMill(idx, ply)) return false;
    const all = board.filter(p=>p.owner===ply);
    return !all.every(p => checkMill(p.id, ply));
}

function removeUnit(idx, owner) {
    board[idx].owner = 0;
    if(owner===2) p2Board--; else p1Board--;
    
    if(p1Left===0 && p2Left===0) {
        if(p1Board < 3) { gameOver(2); return; }
        if(p2Board < 3) { gameOver(1); return; }
    }
    phase = (p1Left>0||p2Left>0)?'PLACING':'MOVING';
    endTurn();
}

function gameOver(winner) {
    phase = 'GAME_OVER';
    updateUI(true, winner===1?"YOU WON!":"GAME OVER", winner===1?"Opponent Eliminated":"System Failure");
}

// --- UI ---
const canvas = document.getElementById('gameBoard');
const ctx = canvas.getContext('2d');
let bs = 0;

function resize() {
    bs = canvas.parentElement.clientWidth;
    const dpr = window.devicePixelRatio || 1;
    canvas.width = bs * dpr; canvas.height = bs * dpr;
    ctx.scale(dpr, dpr);
    canvas.style.width = bs + "px"; canvas.style.height = bs + "px";
    draw();
}
window.addEventListener('resize', resize);

function draw() {
    ctx.clearRect(0,0,bs,bs);
    const s = bs;
    
    ctx.strokeStyle='#333'; ctx.lineWidth=s*0.01; ctx.beginPath();
    board.forEach(p => { adj[p.id].forEach(n => { if(n>p.id) { ctx.moveTo(rawPoints[p.id].x*s, rawPoints[p.id].y*s); ctx.lineTo(rawPoints[n].x*s, rawPoints[n].y*s); }});});
    ctx.stroke();

    board.forEach(p => {
        const px = rawPoints[p.id].x*s; const py = rawPoints[p.id].y*s;
        if(p.owner===0) {
            ctx.fillStyle='#222'; ctx.beginPath(); ctx.arc(px,py,s*0.015,0,Math.PI*2); ctx.fill();
        } else {
            const c = p.owner===1?P1_COLOR:P2_COLOR;
            ctx.fillStyle=c; ctx.shadowColor=c; ctx.shadowBlur=15;
            ctx.beginPath(); ctx.arc(px,py,s*0.03,0,Math.PI*2); ctx.fill(); ctx.shadowBlur=0;
            if(p.id===selectedId) { ctx.strokeStyle='#fff'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(px,py,s*0.05,0,Math.PI*2); ctx.stroke(); }
        }
    });
}

function updateUI(alert, t, sub) {
    const status = document.getElementById('status');
    const subStatus = document.getElementById('sub-status');
    
    if(t) {
        status.innerText = t; subStatus.innerText = sub;
        status.className = alert ? "status-text status-alert" : "status-text";
    } else {
        if(turn===1) { status.innerText="YOUR TURN"; status.className="status-text status-p1"; subStatus.innerText="Move / Place"; }
        else { status.innerText="AI TURN"; status.className="status-text status-p2"; subStatus.innerText="Thinking..."; }
    }
    draw();
}

canvas.addEventListener('mousedown', e => input(e.clientX, e.clientY));
canvas.addEventListener('touchstart', e => { e.preventDefault(); input(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});

function input(cx, cy) {
    const r = canvas.getBoundingClientRect();
    const x = cx-r.left; const y = cy-r.top;
    for(let i=0; i<24; i++) {
        const px = rawPoints[i].x*bs; const py = rawPoints[i].y*bs;
        if(Math.sqrt((x-px)**2 + (y-py)**2) < bs*0.08) { handleInput(i); break; }
    }
}

initGame();
</script>
</body>
</html>

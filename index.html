<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Strategy: Crystal</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg: #050510;
            --p1: #00f2ff; --p1-g: rgba(0, 242, 255, 0.6);
            --p2: #ff0055; --p2-g: rgba(255, 0, 85, 0.6);
            --hint: #a200ff; --hint-g: rgba(162, 0, 255, 0.6);
            --panel: rgba(15, 15, 25, 0.9);
        }
        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; touch-action: none; }
        
        body {
            background-color: var(--bg);
            background-image: radial-gradient(circle at 50% 50%, #121225 0%, #000000 100%);
            color: white; font-family: 'Rajdhani', sans-serif;
            margin: 0; height: 100vh; width: 100vw;
            overflow: hidden; display: flex; flex-direction: column;
        }

        /* --- RESPONSIVE LAYOUT ENGINE --- */
        .main-layout {
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            width: 100%; height: 100%; transition: all 0.3s;
        }

        /* MOBILE (Portrait) */
        .game-area {
            width: 95vw; height: 95vw;
            max-width: 500px; max-height: 500px;
            position: relative; margin-bottom: 10px;
            box-shadow: 0 0 40px rgba(0,0,0,0.5);
            border-radius: 12px;
            background: #000; /* Ensure black bg so neon pops */
        }
        
        .hud-area {
            width: 95%; max-width: 500px;
            background: var(--panel);
            border: 1px solid #333; border-radius: 12px;
            padding: 15px; display: flex; flex-direction: column;
            gap: 10px; backdrop-filter: blur(10px);
        }

        /* DESKTOP (Landscape) */
        @media (min-width: 900px) and (orientation: landscape) {
            .main-layout { flex-direction: row; gap: 50px; }
            
            .game-area {
                width: 75vh; height: 75vh; /* Scale with height */
                max-width: 800px; max-height: 800px;
                border: 3px solid #222;
            }
            
            .hud-area {
                width: 320px; height: 75vh;
                justify-content: center;
                box-shadow: 0 0 30px rgba(0,0,0,0.5);
                border: 2px solid #333;
            }
        }

        /* --- CANVAS --- */
        canvas { width: 100%; height: 100%; display: block; border-radius: 10px; cursor: pointer; }
        .targeting { cursor: crosshair !important; }

        /* --- UI COMPONENTS --- */
        .status-box { text-align: center; margin-bottom: 10px; }
        .status-t { font-family: 'Orbitron'; font-size: 1.8rem; font-weight: bold; margin: 0; }
        .status-s { font-size: 1rem; opacity: 0.7; letter-spacing: 1px; }
        .timer { font-family: 'Orbitron'; font-size: 1.2rem; color: #888; text-align: center; }

        .p1-txt { color: var(--p1); text-shadow: 0 0 10px var(--p1-g); }
        .p2-txt { color: var(--p2); text-shadow: 0 0 10px var(--p2-g); }
        .alert { color: #ffe600; animation: pulse 0.5s infinite; }
        @keyframes pulse { 50% { opacity: 0.5; } }

        .score-row { display: flex; justify-content: space-between; font-family: 'Orbitron'; font-size: 1.1rem; padding: 5px 10px; background: rgba(0,0,0,0.3); border-radius: 5px; }

        /* BUTTONS */
        .btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; width: 100%; }
        .btn {
            background: rgba(255,255,255,0.05); border: 1px solid #444; color: #ccc;
            padding: 12px; font-family: 'Orbitron'; font-size: 0.9rem;
            cursor: pointer; transition: 0.2s; border-radius: 4px;
        }
        .btn:hover { background: rgba(255,255,255,0.1); border-color: #fff; color: #fff; }
        .btn:active { transform: scale(0.95); }
        .btn-hint { border-color: var(--hint); color: var(--hint); }
        
        .full-btn { grid-column: span 2; }

        /* --- MENUS & OVERLAYS --- */
        .overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.96); z-index: 200;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        .menu-btn {
            width: 280px; padding: 15px; margin: 8px;
            background: transparent; border: 2px solid var(--p1); color: var(--p1);
            font-family: 'Orbitron'; font-size: 1.1rem; cursor: pointer;
            text-align: center; box-shadow: 0 0 15px var(--p1-g); transition: 0.2s;
        }
        .menu-btn:hover { background: var(--p1); color: #000; }
        .menu-btn.cpu { border-color: #fff; color: #fff; box-shadow: none; }
        .menu-btn.cpu:hover { background: #fff; color: #000; }

        /* SLIDER */
        .slider-box { width: 280px; background: #111; padding: 15px; border-radius: 8px; border: 1px solid #333; margin: 10px 0; text-align: center; }
        input[type=range] { width: 100%; accent-color: var(--p2); cursor: pointer; }

        /* COIN */
        .coin {
            width: 140px; height: 140px; border-radius: 50%;
            border: 8px solid #fff; background: #1a1a1a;
            display: flex; justify-content: center; align-items: center;
            font-size: 2.5rem; font-family: 'Orbitron'; font-weight: bold;
            box-shadow: 0 0 50px rgba(255,255,255,0.3);
            cursor: pointer; margin-bottom: 20px;
        }
        .coin.flip { animation: spin 0.2s infinite linear; }
        @keyframes spin { 0% { transform: rotateY(0deg); } 100% { transform: rotateY(360deg); } }

    </style>
</head>
<body>

    <div id="main-menu" class="overlay">
        <h1 style="font-family:'Orbitron'; font-size:2.5rem; text-align:center; color:#fff; margin-bottom:10px; text-shadow:0 0 20px rgba(255,255,255,0.2);">NEON STRATEGY<br><span style="font-size:1rem; letter-spacing:5px; opacity:0.6;">CRYSTAL EDITION</span></h1>
        
        <button class="menu-btn" onclick="startGame('PVP')">PLAYER vs PLAYER</button>
        
        <div class="slider-box">
            <div style="font-family:'Orbitron'; color:var(--p2); margin-bottom:5px;">CPU DIFFICULTY: <span id="cpu-val" style="color:#fff">5</span></div>
            <input type="range" id="cpu-slider" min="1" max="10" value="5" oninput="document.getElementById('cpu-val').innerText=this.value">
        </div>
        <button class="menu-btn cpu" onclick="startGame('PVC')">VS CPU</button>
        <button class="menu-btn" style="border-color:#555; color:#888; box-shadow:none; padding:10px; font-size:0.9rem;" onclick="startGame('AVA')">WATCH AI DEMO</button>
    </div>

    <div id="coin-overlay" class="overlay" style="display:none;">
        <div id="coin-visual" class="coin" onclick="startFlip()">FLIP</div>
        <div id="coin-msg" style="text-align:center; font-family:'Orbitron'; font-size:1.4rem;">DEADLOCK!<br><span style="font-size:0.9rem; color:#888">Flip to Kill & Make Space</span></div>
    </div>

    <div class="main-layout" id="layout">
        
        <div class="game-area" id="game-container">
            <canvas id="gameBoard"></canvas>
        </div>

        <div class="hud-area">
            <div class="timer" id="game-timer">00:00</div>
            
            <div class="status-box">
                <div class="status-t p1-txt" id="status-t">YOUR TURN</div>
                <div class="status-s" id="status-sub">Place Unit</div>
            </div>
            
            <div class="score-row">
                <div class="p1-txt">P1: <span id="s1">12</span></div>
                <div class="p2-txt">OPP: <span id="s2">12</span></div>
            </div>

            <div class="btn-grid">
                <button class="btn btn-hint" onclick="getHint()">ðŸ’¡ HINT</button>
                <button class="btn" onclick="undoMove()">UNDO</button>
                <button class="btn full-btn" onclick="resetGame()">RESTART MATCH</button>
                <button class="btn full-btn" style="border:none; color:#555;" onclick="location.reload()">EXIT TO MENU</button>
            </div>
        </div>
    </div>

<script>
/** NEON STRATEGY CRYSTAL ENGINE (HOTFIX) **/

// --- AUDIO SYSTEM ---
const AudioSys = {
    ctx: new (window.AudioContext || window.webkitAudioContext)(),
    tone(f, t, d) {
        if(this.ctx.state === 'suspended') this.ctx.resume();
        const o=this.ctx.createOscillator(), g=this.ctx.createGain();
        o.type=t; o.frequency.setValueAtTime(f, this.ctx.currentTime);
        g.gain.setValueAtTime(0.1, this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime+d);
        o.connect(g); g.connect(this.ctx.destination); o.start(); o.stop(this.ctx.currentTime+d);
    },
    click: ()=> AudioSys.tone(800, 'sine', 0.1),
    place: ()=> AudioSys.tone(400, 'square', 0.15),
    kill: ()=> { AudioSys.tone(150, 'sawtooth', 0.2); setTimeout(()=>AudioSys.tone(100,'sawtooth',0.3),100); },
    flip: ()=> AudioSys.tone(1200, 'triangle', 0.05),
    win: ()=> AudioSys.tone(600, 'sine', 0.4)
};

// --- DATA ---
const RAW_PTS=[{x:0.1,y:0.1},{x:0.5,y:0.1},{x:0.9,y:0.1},{x:0.9,y:0.5},{x:0.9,y:0.9},{x:0.5,y:0.9},{x:0.1,y:0.9},{x:0.1,y:0.5},{x:0.25,y:0.25},{x:0.5,y:0.25},{x:0.75,y:0.25},{x:0.75,y:0.5},{x:0.75,y:0.75},{x:0.5,y:0.75},{x:0.25,y:0.75},{x:0.25,y:0.5},{x:0.4,y:0.4},{x:0.5,y:0.4},{x:0.6,y:0.4},{x:0.6,y:0.5},{x:0.6,y:0.6},{x:0.5,y:0.6},{x:0.4,y:0.6},{x:0.4,y:0.5}];
const ADJ=[[1,7,8],[0,2,9],[1,3,10],[2,4,11],[3,5,12],[4,6,13],[5,7,14],[0,6,15],[0,9,15,16],[1,8,10,17],[2,9,11,18],[3,10,12,19],[4,11,13,20],[5,12,14,21],[6,13,15,22],[7,8,14,23],[8,17,23],[9,16,18],[10,17,19],[11,18,20],[12,19,21],[13,20,22],[14,21,23],[15,16,22]];
const MILLS=[[0,1,2],[2,3,4],[4,5,6],[6,7,0],[8,9,10],[10,11,12],[12,13,14],[14,15,8],[16,17,18],[18,19,20],[20,21,22],[22,23,16],[0,8,16],[2,10,18],[4,12,20],[6,14,22],[1,9,17],[3,11,19],[5,13,21],[7,15,23]];

// --- STATE ---
let mode='PVC', diff=5, turn=1, phase='PLACING';
let board=[], p1Left=12, p2Left=12, p1Board=0, p2Board=0;
let selectedId=-1, validMoves=[], historyStack=[], hintMove=null;
let timerInt=null, seconds=0, particles=[];

function startGame(m) {
    mode=m; diff=parseInt(document.getElementById('cpu-slider').value);
    document.getElementById('main-menu').style.display='none';
    resetGame();
}

function resetGame() {
    board=RAW_PTS.map((p,i)=>({id:i, owner:0}));
    turn=1; phase='PLACING'; p1Left=12; p2Left=12; p1Board=0; p2Board=0;
    selectedId=-1; validMoves=[]; historyStack=[]; particles=[]; hintMove=null; seconds=0;
    document.getElementById('coin-overlay').style.display='none';
    clearInterval(timerInt); timerInt=setInterval(()=>{ seconds++; let m=Math.floor(seconds/60), s=seconds%60; document.getElementById('game-timer').innerText=`${m}:${s<10?'0':''}${s}`; },1000);
    resize(); updateUI();
    if(mode==='AVA') setTimeout(aiMove, 1000);
}

// --- UNDO ---
function saveState() {
    historyStack.push(JSON.stringify({board, turn, phase, p1Left, p2Left, p1Board, p2Board}));
    if(historyStack.length>10) historyStack.shift();
}
function undoMove() {
    if(historyStack.length===0 || phase==='GAME_OVER') return;
    let steps = (mode==='PVC' && turn===1) ? 2 : 1;
    if(historyStack.length < steps) return;
    for(let i=0; i<steps; i++) {
        let state = JSON.parse(historyStack.pop());
        board=state.board; turn=state.turn; phase=state.phase;
        p1Left=state.p1Left; p2Left=state.p2Left; p1Board=state.p1Board; p2Board=state.p2Board;
    }
    selectedId=-1; validMoves=[]; hintMove=null;
    AudioSys.click(); updateUI();
}

// --- LOGIC ---
function isFlying(ply) { return phase==='MOVING' && ((ply===1?p1Board:p2Board)===3) && ((ply===1?p1Left:p2Left)===0); }

function handleInput(idx) {
    if(mode==='AVA') return;
    if(mode==='PVC' && turn===2) return;
    if(phase==='TRAPPED' || phase==='GAME_OVER') return;

    if(phase==='PLACING') {
        if(board[idx].owner!==0) return;
        saveState(); move(idx, turn, 'PLACE'); AudioSys.place();
    }
    else if(phase==='MOVING') {
        if(board[idx].owner===turn) { 
            selectedId=idx; 
            validMoves = [];
            if(isFlying(turn)) board.forEach(p=>{if(p.owner===0)validMoves.push(p.id)});
            else ADJ[idx].forEach(n=>{if(board[n].owner===0)validMoves.push(n)});
            updateUI(); AudioSys.click();
        }
        else if(selectedId!==-1 && board[idx].owner===0) {
            if(isFlying(turn) || ADJ[selectedId].includes(idx)) {
                saveState(); move(idx, turn, 'MOVE', selectedId); AudioSys.click();
            }
        }
    }
    else if(phase==='REMOVING') {
        const enemy = turn===1?2:1;
        if(board[idx].owner===enemy) {
            if(isProtected(idx, enemy)) { alert("Protected!"); return; }
            saveState(); kill(idx, enemy);
        }
    }
}

function move(to, ply, type, from) {
    board[to].owner = ply;
    if(type==='PLACE') { if(ply===1)p1Left--; else p2Left--; if(ply===1)p1Board++; else p2Board++; }
    if(type==='MOVE') { board[from].owner=0; selectedId=-1; validMoves=[]; }
    hintMove = null;

    if(checkMill(to, ply)) {
        phase='REMOVING';
        if(mode!=='PVP' && ply===2) setTimeout(aiKill, 800);
        else if(mode==='AVA') setTimeout(aiKill, 800);
        else updateUI(true, "TARGET LOCKED", "Destroy Enemy");
    } else {
        endTurn();
    }
}

function kill(idx, owner) {
    const pt = RAW_PTS[idx];
    spawnParticles(pt.x, pt.y, owner===2?P2_COL:P1_COL);
    AudioSys.kill();

    board[idx].owner = 0;
    if(owner===2) p2Board--; else p1Board--;
    
    if(p1Left===0 && p2Left===0) {
        if(p2Board<3) { gameOver(1); return; }
        if(p1Board<3) { gameOver(2); return; }
    }
    phase = (p1Left>0||p2Left>0)?'PLACING':'MOVING';
    endTurn();
}

function endTurn() {
    if(phase==='GAME_OVER') return;
    turn = (turn===1)?2:1;
    validMoves=[]; hintMove=null;
    
    // DEADLOCK CHECK
    if(phase==='MOVING') {
        let moves = getAllMoves(turn);
        if(moves.length === 0) {
            phase='TRAPPED'; showCoinFlip(turn); return;
        }
    }

    updateUI();
    if(mode==='AVA') setTimeout(aiMove, 800);
    else if(mode==='PVC' && turn===2) setTimeout(aiMove, 600);
}

// --- COIN FLIP ---
function showCoinFlip(who) {
    const ov = document.getElementById('coin-overlay');
    const msg = document.getElementById('coin-msg');
    const coin = document.getElementById('coin-visual');
    ov.style.display = 'flex';
    coin.className = 'coin'; coin.innerText = "FLIP";
    
    let pName = who===1?"P1":"CPU";
    msg.innerHTML = `<span style="color:${who===1?P1_COL:P2_COL}">${pName} TRAPPED!</span><br>Flip to Kill`;

    if((mode==='PVC' && who===2) || mode==='AVA') { coin.onclick=null; setTimeout(flip, 1500); }
    else { coin.onclick = flip; }
}

function flip() {
    const coin = document.getElementById('coin-visual');
    const msg = document.getElementById('coin-msg');
    coin.className = 'coin flip'; coin.innerText = "";
    AudioSys.flip();
    
    setTimeout(()=>{
        let win = Math.random()>0.5;
        coin.className = 'coin'; 
        coin.style.borderColor = win?'#0f0':'#f00';
        coin.style.color = win?'#0f0':'#f00';
        coin.innerText = win? (turn===1?"P1":"CPU") : "FAIL";
        
        if(win) {
            msg.innerHTML = "WINNER<br><span style='color:#0f0'>Kill confirmed!</span>";
            if(turn===1 && mode!=='AVA') AudioSys.win();
            setTimeout(()=>{
                document.getElementById('coin-overlay').style.display='none';
                phase='REMOVING';
                if((turn===2 && mode==='PVC') || mode==='AVA') aiKill(); 
                else updateUI(true, "TARGET LOCKED", "Shoot to Free Yourself!"); 
            }, 1500);
        } else {
            msg.innerHTML = "LOSS<br><span style='color:#f00'>Self Destruct...</span>";
            setTimeout(()=>{ gameOver(turn===1?2:1); }, 1500);
        }
    }, 1000);
}

// --- AI & UTILS ---
function getHint() {
    let moves = getAllMoves(turn);
    if(moves.length===0) return;
    let bestScore=-Infinity, bestM=moves[0];
    for(let m of moves) {
        let prev=board[m.to].owner; board[m.to].owner=turn; if(m.type==='MOVE')board[m.from].owner=0;
        let score=minimax(1, false, -Infinity, Infinity, turn);
        board[m.to].owner=prev; if(m.type==='MOVE')board[m.from].owner=turn;
        if(score>bestScore){bestScore=score; bestM=m;}
    }
    hintMove=bestM; AudioSys.click();
}

function aiMove() {
    if(phase==='TRAPPED') return;
    let moves = getAllMoves(turn);
    if(moves.length===0) return; 

    let depth = 1;
    if(diff>=5) depth=2; if(diff>=8) depth=3;
    if(isFlying(turn)) depth=1;

    let bestScore = -Infinity, bestMove = moves[0];

    if(diff <= 3) { bestMove = moves[Math.floor(Math.random()*moves.length)]; }
    else {
        for(let m of moves) {
            let prev = board[m.to].owner;
            board[m.to].owner=turn; if(m.type==='MOVE') board[m.from].owner=0;
            let score = minimax(depth, false, -Infinity, Infinity, turn);
            board[m.to].owner=prev; if(m.type==='MOVE') board[m.from].owner=turn;
            if(diff<8) score += Math.random()*20;
            if(score > bestScore) { bestScore=score; bestMove=m; }
        }
    }
    move(bestMove.to, turn, bestMove.type, bestMove.from);
}

function minimax(d, isMax, alpha, beta, ply) {
    if(d===0) return evaluate(ply);
    let currPly = isMax ? ply : (ply===1?2:1);
    let moves = getAllMoves(currPly);
    if(moves.length===0) return isMax?-5000:5000;

    let best = isMax?-Infinity:Infinity;
    for(let m of moves) {
        let prev = board[m.to].owner;
        board[m.to].owner=currPly; if(m.type==='MOVE') board[m.from].owner=0;
        let val = minimax(d-1, !isMax, alpha, beta, ply);
        board[m.to].owner=prev; if(m.type==='MOVE') board[m.from].owner=currPly;
        if(isMax) { best = Math.max(best, val); alpha = Math.max(alpha, best); }
        else { best = Math.min(best, val); beta = Math.min(beta, best); }
        if(beta <= alpha) break;
    }
    return best;
}

function evaluate(ply) {
    let opp = ply===1?2:1;
    let myCount = ply===1?p1Board:p2Board;
    let oppCount = ply===1?p2Board:p1Board;
    return (myCount-oppCount)*100 + countMills(ply)*50;
}

function aiKill() {
    let enemy = turn===1?2:1;
    let targets = board.filter(p=>p.owner===enemy && !isProtected(p.id, enemy));
    if(targets.length>0) {
        targets.sort((a,b) => countAdj(b.id,enemy) - countAdj(a.id,enemy));
        kill(targets[0].id, enemy);
    } else { phase=(p1Left>0||p2Left>0)?'PLACING':'MOVING'; endTurn(); }
}

function getAllMoves(ply) {
    let m=[];
    if(phase==='PLACING') board.forEach(p=>{if(p.owner===0)m.push({to:p.id, type:'PLACE'})});
    else {
        let flying = isFlying(ply);
        board.forEach(p=>{
            if(p.owner===ply) {
                if(flying) board.forEach(e=>{if(e.owner===0)m.push({from:p.id, to:e.id, type:'MOVE'})});
                else ADJ[p.id].forEach(n=>{if(board[n].owner===0)m.push({from:p.id, to:n, type:'MOVE'})});
            }
        });
    }
    return m;
}
function checkMill(idx, ply) { for(let m of MILLS) if(m.includes(idx) && board[m[0]].owner===ply && board[m[1]].owner===ply && board[m[2]].owner===ply) return true; return false; }
function isProtected(idx, ply) { if(!checkMill(idx, ply)) return false; let all=board.filter(p=>p.owner===ply); return !all.every(p=>checkMill(p.id, ply)); }
function countMills(ply) { let c=0; MILLS.forEach(m=>{if(board[m[0]].owner===ply && board[m[1]].owner===ply && board[m[2]].owner===ply)c++}); return c; }
function countAdj(idx, ply) { return ADJ[idx].filter(n=>board[n].owner===ply).length; }
function gameOver(w) { document.getElementById('coin-overlay').style.display='none'; phase='GAME_OVER'; updateUI(true, (w===1?"P1":"P2")+" WINS!", "Game Over"); AudioSys.win(); clearInterval(timerInt); }

// --- RENDER & INPUT FIX ---
const cvs=document.getElementById('gameBoard'), ctx=cvs.getContext('2d');
let bs=0;

function resize() {
    let rect = cvs.getBoundingClientRect();
    bs = rect.width;
    cvs.width = rect.width; cvs.height = rect.height; // Match internal size to CSS
    draw();
}
window.onresize=resize;

function spawnParticles(x, y, color) {
    // x,y are normalized 0-1
    for(let i=0; i<15; i++) particles.push({x:x, y:y, vx:(Math.random()-0.5)*0.02, vy:(Math.random()-0.5)*0.02, life:1.0, color:color});
}

function draw() {
    ctx.clearRect(0,0,cvs.width,cvs.height);
    
    // Use actual dimensions
    let w = cvs.width; let h = cvs.height;

    // Grid
    ctx.strokeStyle='#333'; ctx.lineWidth=w*0.01; ctx.beginPath();
    board.forEach(p=>ADJ[p.id].forEach(n=>{if(n>p.id){ctx.moveTo(RAW_PTS[p.id].x*w,RAW_PTS[p.id].y*h); ctx.lineTo(RAW_PTS[n].x*w,RAW_PTS[n].y*h)}}));
    ctx.stroke();

    // Assist
    if(validMoves.length>0) {
        ctx.fillStyle='rgba(0, 255, 100, 0.2)';
        validMoves.forEach(id=>{let pt=RAW_PTS[id]; ctx.beginPath(); ctx.arc(pt.x*w, pt.y*h, w*0.04, 0, Math.PI*2); ctx.fill();});
    }
    if(hintMove) {
        let pt=RAW_PTS[hintMove.to];
        ctx.strokeStyle='#a200ff'; ctx.lineWidth=3; ctx.shadowColor='#a200ff'; ctx.shadowBlur=15;
        ctx.beginPath(); ctx.arc(pt.x*w, pt.y*h, w*0.06, 0, Math.PI*2); ctx.stroke(); ctx.shadowBlur=0;
    }

    // Units
    board.forEach(p=>{
        let x=RAW_PTS[p.id].x*w, y=RAW_PTS[p.id].y*h;
        if(p.owner===0) { ctx.fillStyle='#222'; ctx.beginPath(); ctx.arc(x,y,w*0.015,0,Math.PI*2); ctx.fill(); }
        else {
            let col=p.owner===1?P1_COL:P2_COL;
            ctx.fillStyle=col; ctx.shadowBlur=15; ctx.shadowColor=col;
            ctx.beginPath(); ctx.arc(x,y,w*0.035,0,Math.PI*2); ctx.fill(); ctx.shadowBlur=0;
            if(phase==='REMOVING' && turn===1 && p.owner===2 && !isProtected(p.id,2)) {
                ctx.strokeStyle='#fff'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(x,y,w*0.05,0,Math.PI*2); ctx.stroke();
            }
            if(p.id===selectedId) { ctx.strokeStyle='#fff'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(x,y,w*0.055,0,Math.PI*2); ctx.stroke(); }
        }
    });

    // Particles
    particles.forEach((p,i)=>{
        p.x+=p.vx; p.y+=p.vy; p.life-=0.05;
        ctx.globalAlpha=p.life; ctx.fillStyle=p.color;
        ctx.beginPath(); ctx.arc(p.x*w, p.y*h, 3, 0, Math.PI*2); ctx.fill();
        if(p.life<=0) particles.splice(i,1);
    });
    ctx.globalAlpha=1;
    requestAnimationFrame(draw);
}

function updateUI(alert, t, sub) {
    const s1=document.getElementById('s1'), s2=document.getElementById('s2');
    const st=document.getElementById('status-t'), ss=document.getElementById('status-sub');
    s1.innerText = phase==='PLACING'?p1Left:p1Board;
    s2.innerText = phase==='PLACING'?p2Left:p2Board;
    
    if(t) { st.innerText=t; ss.innerText=sub; st.className=alert?"status-t alert":"status-t"; }
    else {
        let name = turn===1?"PLAYER 1":(mode==='PVC'?"CPU":(mode==='AVA'?"AI 1":"PLAYER 2"));
        st.innerText = name+" TURN"; st.className=turn===1?"status-t p1-turn":"status-t p2-turn";
        ss.innerText = phase==='PLACING'?"Place Unit":"Move Unit";
        if(isFlying(turn)) ss.innerText = "FLYING MODE ENABLED";
    }
    if(phase==='REMOVING' && turn===1 && mode!=='AVA') cvs.style.cursor='crosshair'; else cvs.style.cursor='default';
}

// Input Fix: Get exact mouse pos relative to canvas
function getPos(e) {
    const rect = cvs.getBoundingClientRect();
    const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
    const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
    // Normalized 0-1
    return { x: x/rect.width, y: y/rect.height };
}

function handleStart(e) {
    if(e.type === 'touchstart') e.preventDefault(); // Stop scroll
    const pos = getPos(e);
    // Find closest point
    for(let i=0; i<24; i++) {
        let p = RAW_PTS[i];
        let dist = Math.sqrt(Math.pow(pos.x - p.x, 2) + Math.pow(pos.y - p.y, 2));
        if(dist < 0.08) { handleInput(i); break; }
    }
}

cvs.addEventListener('mousedown', handleStart);
cvs.addEventListener('touchstart', handleStart, {passive: false});

// Init on Load
resize();
</script>
</body>
</html>

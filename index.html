<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#050510">
    <title>Neon Strategy 24: AI Edition</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-color: #050510;
            --p1-color: #00f2ff; /* Player Color */
            --p1-glow: rgba(0, 242, 255, 0.6);
            --p2-color: #ff0055; /* AI / P2 Color */
            --p2-glow: rgba(255, 0, 85, 0.6);
            --grid-line: #2a2a40;
            --grid-glow: #4d4d80;
            --text-color: #e0e0e0;
            --panel-bg: rgba(20, 20, 35, 0.95);
        }

        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }

        body {
            font-family: 'Rajdhani', sans-serif;
            background-color: var(--bg-color);
            background-image: radial-gradient(circle at 50% 50%, #1a1a2e 0%, #000000 100%);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            padding-top: 5px;
        }

        /* --- UI Elements --- */
        h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            margin: 5px 0;
            background: -webkit-linear-gradient(#fff, #888);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .game-wrapper {
            width: 95%; max-width: 500px;
            aspect-ratio: 1 / 1;
            position: relative;
            margin-bottom: 5px;
        }

        .game-container {
            width: 100%; height: 100%;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
            border-radius: 12px;
            padding: 4px;
            background: linear-gradient(45deg, var(--p1-color), transparent, var(--p2-color));
        }

        canvas {
            background-color: #0a0a12;
            border-radius: 8px;
            display: block;
            width: 100%; height: 100%;
            touch-action: none;
        }

        .hud-panel {
            background: rgba(20, 20, 35, 0.95);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding: 10px 15px;
            border-radius: 16px 16px 0 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            flex-grow: 1;
        }

        .status-text { font-size: 1.3rem; font-weight: 700; text-align: center; margin-bottom: 2px; text-shadow: 0 0 10px currentColor; }
        .status-p1 { color: var(--p1-color); }
        .status-p2 { color: var(--p2-color); }
        .sub-text { font-size: 0.9rem; opacity: 0.7; margin-bottom: 8px; }

        .indicators { display: flex; justify-content: space-between; width: 100%; max-width: 400px; margin-bottom: 5px; font-size: 0.8rem; }
        .ind-box { padding: 4px 8px; border-radius: 4px; background: rgba(255,255,255,0.05); }

        /* --- Modals (Menu & Rules) --- */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.92);
            z-index: 2000;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .modal-content {
            background: #101018;
            border: 2px solid var(--p1-color);
            padding: 25px;
            border-radius: 12px;
            width: 100%; max-width: 380px;
            text-align: center;
            box-shadow: 0 0 50px rgba(0,242,255,0.1);
        }

        .btn {
            background: transparent;
            border: 1px solid var(--p1-color);
            color: var(--p1-color);
            padding: 12px;
            margin: 8px 0;
            width: 100%;
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
            text-transform: uppercase;
            cursor: pointer;
            transition: 0.2s;
        }
        .btn:active, .btn.selected { background: var(--p1-color); color: #000; }
        
        .level-select { display: flex; gap: 5px; margin-bottom: 15px; }
        .lvl-btn { flex: 1; font-size: 0.8rem; padding: 8px 0; border: 1px solid #444; color: #888; }
        .lvl-btn.active { border-color: var(--p2-color); background: var(--p2-color); color: white; }

        .hidden { display: none !important; }

    </style>
</head>
<body>

    <div id="start-menu" class="modal-overlay">
        <div class="modal-content">
            <h2 style="color:white; font-family:'Orbitron'; margin-top:0;">SYSTEM START</h2>
            
            <p style="color:#aaa; font-size:0.9rem; margin-bottom:5px;">SELECT OPPONENT</p>
            <div style="display:flex; gap:10px;">
                <button class="btn" id="btn-pvp" onclick="selectMode('PVP')">2 PLAYERS</button>
                <button class="btn selected" id="btn-pvc" onclick="selectMode('PVC')">VS COMPUTER</button>
            </div>

            <div id="ai-options">
                <p style="color:#aaa; font-size:0.9rem; margin: 15px 0 5px 0;">AI DIFFICULTY LEVEL</p>
                <div class="level-select">
                    <button class="lvl-btn" onclick="setAiLevel(1)">1</button>
                    <button class="lvl-btn" onclick="setAiLevel(2)">2</button>
                    <button class="lvl-btn active" onclick="setAiLevel(3)">3</button>
                    <button class="lvl-btn" onclick="setAiLevel(4)">4</button>
                    <button class="lvl-btn" onclick="setAiLevel(5)">5</button>
                </div>
                <div id="lvl-desc" style="color:var(--p2-color); font-size:0.8rem; margin-bottom:15px;">LEVEL 3: SOLDIER (Balanced)</div>
            </div>

            <button class="btn" style="border-color:white; color:white; margin-top:20px;" onclick="startGame()">INITIATE</button>
        </div>
    </div>

    <h1>NEON STRATEGY 24</h1>

    <div class="game-wrapper">
        <div class="game-container">
            <canvas id="gameBoard"></canvas>
        </div>
    </div>

    <div class="hud-panel">
        <div class="indicators">
            <div class="ind-box" style="border-left: 3px solid var(--p1-color)">P1: <span id="p1-score">12</span></div>
            <div class="ind-box" style="border-right: 3px solid var(--p2-color)"><span id="p2-name">CPU</span>: <span id="p2-score">12</span></div>
        </div>
        <div id="status" class="status-text status-p1">READY</div>
        <div id="sub-status" class="sub-text">Waiting for input...</div>
        
        <button class="btn" style="width:auto; padding:8px 30px; font-size:0.8rem;" onclick="location.reload()">MAIN MENU</button>
    </div>

<script>
/* --- GAME CONFIGURATION --- */
const P1_COLOR = '#00f2ff'; const P1_GLOW = 'rgba(0, 242, 255, 0.6)';
const P2_COLOR = '#ff0055'; const P2_GLOW = 'rgba(255, 0, 85, 0.6)';
const TOTAL_COINS = 12;

let gameMode = 'PVC'; // PVP or PVC
let aiLevel = 3; // 1 to 5
let turn = 1; // 1 (Player) or 2 (AI/P2)
let phase = 'PLACING'; 
let p1Left = TOTAL_COINS; let p2Left = TOTAL_COINS;
let p1Board = 0; let p2Board = 0;
let selectedId = -1;
let isAiThinking = false;

// 24 Points Data
const rawPoints = [
    {x:0.1,y:0.1},{x:0.5,y:0.1},{x:0.9,y:0.1}, {x:0.9,y:0.5},{x:0.9,y:0.9},{x:0.5,y:0.9}, {x:0.1,y:0.9},{x:0.1,y:0.5},
    {x:0.25,y:0.25},{x:0.5,y:0.25},{x:0.75,y:0.25}, {x:0.75,y:0.5},{x:0.75,y:0.75},{x:0.5,y:0.75}, {x:0.25,y:0.75},{x:0.25,y:0.5},
    {x:0.4,y:0.4},{x:0.5,y:0.4},{x:0.6,y:0.4}, {x:0.6,y:0.5},{x:0.6,y:0.6},{x:0.5,y:0.6}, {x:0.4,y:0.6},{x:0.4,y:0.5}
];
const adj = [
    [1,7,8],[0,2,9],[1,3,10],[2,4,11],[3,5,12],[4,6,13],[5,7,14],[0,6,15],
    [0,9,15,16],[1,8,10,17],[2,9,11,18],[3,10,12,19],[4,11,13,20],[5,12,14,21],[6,13,15,22],[7,8,14,23],
    [8,17,23],[9,16,18],[10,17,19],[11,18,20],[12,19,21],[13,20,22],[14,21,23],[15,16,22]
];
const mills = [
    [0,1,2],[2,3,4],[4,5,6],[6,7,0], [8,9,10],[10,11,12],[12,13,14],[14,15,8],
    [16,17,18],[18,19,20],[20,21,22],[22,23,16], [1,9,17],[3,11,19],[5,13,21],[7,15,23],
    [0,8,16],[2,10,18],[4,12,20],[6,14,22]
];

// State: 0=Empty, 1=P1, 2=P2/AI
let board = rawPoints.map((p,i)=>({id:i, owner:0}));

/* --- MENU LOGIC --- */
function selectMode(m) {
    gameMode = m;
    document.getElementById('btn-pvp').className = m==='PVP'?'btn selected':'btn';
    document.getElementById('btn-pvc').className = m==='PVC'?'btn selected':'btn';
    document.getElementById('ai-options').style.display = m==='PVC'?'block':'none';
    document.getElementById('p2-name').innerText = m==='PVC'?'AI':'P2';
}

function setAiLevel(l) {
    aiLevel = l;
    document.querySelectorAll('.lvl-btn').forEach((b,i) => {
        b.className = (i+1)===l ? 'lvl-btn active' : 'lvl-btn';
    });
    const desc = ["LEVEL 1: DRONE (Random)", "LEVEL 2: RECRUIT (Basic)", "LEVEL 3: SOLDIER (Balanced)", "LEVEL 4: VETERAN (Smart)", "LEVEL 5: WARLORD (Expert)"];
    document.getElementById('lvl-desc').innerText = desc[l-1];
}

function startGame() {
    document.getElementById('start-menu').classList.add('hidden');
    resetGame();
}

/* --- CORE GAME LOOP --- */
function resetGame() {
    turn=1; phase='PLACING';
    p1Left=TOTAL_COINS; p2Left=TOTAL_COINS;
    p1Board=0; p2Board=0;
    selectedId=-1; isAiThinking=false;
    board.forEach(p=>p.owner=0);
    updateUI(); draw();
}

function handleInput(idx) {
    if(isAiThinking) return;
    if(gameMode === 'PVC' && turn === 2) return; // Not player's turn

    executeMove(idx, 1);
}

function executeMove(idx, player) {
    // 1. PLACING PHASE
    if(phase === 'PLACING') {
        if(board[idx].owner !== 0) return; // Occupied
        board[idx].owner = player;
        if(player===1) { p1Left--; p1Board++; } else { p2Left--; p2Board++; }
        
        if(checkMill(idx, player)) {
            phase = 'REMOVING';
            updateUI(true, "TARGET LOCKED", player===1 ? "Tap AI unit to destroy" : "AI is targeting you...");
            if(gameMode === 'PVC' && turn === 2) setTimeout(aiRemove, 1000);
            return;
        }
        
        if(p1Left===0 && p2Left===0) { phase='MOVING'; endTurn(); }
        else endTurn();
    }
    // 2. MOVING PHASE
    else if(phase === 'MOVING') {
        if(board[idx].owner === player) {
            selectedId = idx;
            updateUI();
            return;
        }
        if(selectedId !== -1 && board[idx].owner === 0) {
            if(!adj[selectedId].includes(idx)) return; // Not connected
            
            board[idx].owner = player;
            board[selectedId].owner = 0;
            selectedId = -1;
            
            if(checkMill(idx, player)) {
                phase = 'REMOVING';
                updateUI(true, "TARGET LOCKED", player===1 ? "Tap AI unit to destroy" : "AI is targeting you...");
                if(gameMode === 'PVC' && turn === 2) setTimeout(aiRemove, 1000);
                return;
            }
            endTurn();
        }
    }
    // 3. REMOVING PHASE
    else if(phase === 'REMOVING') {
        const enemy = player===1 ? 2 : 1;
        if(board[idx].owner !== enemy) return;
        
        // Protection Rule
        if(isPartOfMill(idx, enemy) && !allEnemiesProtected(enemy)) {
            if(player===1) updateUI(true, "PROTECTED", "Cannot remove unit in a line");
            return;
        }

        board[idx].owner = 0;
        if(enemy===1) p1Board--; else p2Board--;
        
        if(p1Left===0 && p2Left===0) {
            if(p1Board < 3) { gameOver(2); return; }
            if(p2Board < 3) { gameOver(1); return; }
        }

        phase = (p1Left>0 || p2Left>0) ? 'PLACING' : 'MOVING';
        endTurn();
    }
}

function endTurn() {
    turn = turn===1 ? 2 : 1;
    updateUI();
    
    if(gameMode === 'PVC' && turn === 2) {
        isAiThinking = true;
        setTimeout(aiTurn, 800 + Math.random()*500); // Simulate thinking time
    } else {
        isAiThinking = false;
    }
}

/* --- AI ENGINE (THE BRAIN) --- */
function aiTurn() {
    if(phase === 'REMOVING') return; // Handled separately

    let move = -1;
    let from = -1;

    // --- PHASE 1: PLACING ---
    if(phase === 'PLACING') {
        move = getBestPlacement();
        executeMove(move, 2);
    } 
    // --- PHASE 2: MOVING ---
    else if(phase === 'MOVING') {
        const best = getBestMove();
        if(best) {
            selectedId = best.from;
            executeMove(best.to, 2);
        }
    }
}

function aiRemove() {
    // Find best target to kill
    // Prioritize: 1. Enemy forming a mill next turn. 2. Enemy blocking my mill. 3. Random.
    const targets = board.filter(p => p.owner === 1);
    let bestTarget = -1;
    let bestScore = -999;

    targets.forEach(t => {
        let score = 0;
        // Logic: Can we kill it?
        if(isPartOfMill(t.id, 1) && !allEnemiesProtected(1)) return; // Protected

        // Heuristics
        if(isPartOfMill(t.id, 1)) score += 50; // Break a mill (if allowed)
        if(aiLevel > 2 && checkPotentialMill(t.id, 1)) score += 30; // Prevent future mill
        score += Math.random() * 10;

        if(score > bestScore) { bestScore = score; bestTarget = t.id; }
    });

    if(bestTarget !== -1) executeMove(bestTarget, 2);
}

// --- AI HEURISTICS ---
function getBestPlacement() {
    const empty = board.filter(p => p.owner === 0);
    
    // Level 1: Random
    if(aiLevel === 1) return empty[Math.floor(Math.random()*empty.length)].id;

    let bestSpot = -1;
    let maxScore = -10000;

    empty.forEach(spot => {
        let score = evaluatePosition(spot.id, 2);
        if(score > maxScore) { maxScore = score; bestSpot = spot.id; }
    });
    return bestSpot;
}

function getBestMove() {
    const myUnits = board.filter(p => p.owner === 2);
    let bestMove = null;
    let maxScore = -10000;

    myUnits.forEach(unit => {
        adj[unit.id].forEach(neighbor => {
            if(board[neighbor].owner === 0) {
                // Simulate Move
                board[unit.id].owner = 0;
                board[neighbor].owner = 2; // Temp Move
                
                let score = evaluatePosition(neighbor, 2);
                
                // Revert
                board[neighbor].owner = 0;
                board[unit.id].owner = 2;

                if(score > maxScore) { maxScore = score; bestMove = {from: unit.id, to: neighbor}; }
            }
        });
    });
    return bestMove;
}

function evaluatePosition(idx, player) {
    let score = Math.random() * 5; // Base randomness
    const enemy = player===1 ? 2 : 1;

    // 1. Instant Win (Form Mill)
    if(checkMill(idx, player)) score += 1000;

    // 2. Block Enemy Mill (Crucial for lvl 3+)
    if(aiLevel >= 3) {
        // Temporarily treat this spot as enemy to see if it makes a mill
        board[idx].owner = enemy;
        if(checkMill(idx, enemy)) score += 800;
        board[idx].owner = player; // Restore (or 0 if placing)
        if(phase==='PLACING') board[idx].owner = 0; 
    }

    // 3. Setup (Two in a row) - Lvl 4+
    if(aiLevel >= 4) {
        if(checkPotentialMill(idx, player)) score += 50;
    }

    // 4. Strategic Position (Cross Points) - Lvl 5
    if(aiLevel === 5) {
        if(adj[idx].length === 4) score += 20; // Intersection points are valuable
    }

    return score;
}

function checkPotentialMill(idx, player) {
    // Returns true if this spot creates 2-in-a-row
    let count = 0;
    mills.forEach(m => {
        if(m.includes(idx)) {
            let occupied = 0;
            let empty = 0;
            m.forEach(p => {
                if(p === idx) return;
                if(board[p].owner === player) occupied++;
                if(board[p].owner === 0) empty++;
            });
            if(occupied === 1 && empty === 1) count++;
        }
    });
    return count > 0;
}

/* --- UTILS --- */
function checkMill(idx, player) {
    for(let m of mills) {
        if(m.includes(idx)) {
            if(board[m[0]].owner===player && board[m[1]].owner===player && board[m[2]].owner===player) return true;
        }
    }
    return false;
}
function isPartOfMill(idx, player) { return checkMill(idx, player); }
function allEnemiesProtected(enemy) {
    const enemies = board.filter(p=>p.owner===enemy);
    return enemies.every(e => isPartOfMill(e.id, enemy));
}

function gameOver(winner) {
    document.getElementById('status').innerText = winner===1 ? "YOU WIN" : "SYSTEM WINS";
    document.getElementById('status').className = "status-text status-neutral";
    document.getElementById('sub-status').innerText = "Game Over";
    phase = 'GAME_OVER';
}

function updateUI(alert, title, sub) {
    document.getElementById('p1-score').innerText = (phase==='PLACING') ? p1Left : p1Board;
    document.getElementById('p2-score').innerText = (phase==='PLACING') ? p2Left : p2Board;
    
    const sEl = document.getElementById('status');
    const ssEl = document.getElementById('sub-status');
    
    sEl.className = "status-text " + (turn===1?"status-p1":"status-p2");
    
    if(title) {
        sEl.innerText = title; ssEl.innerText = sub;
    } else {
        const name = turn===1 ? "P1 TURN" : (gameMode==='PVC' ? "AI THINKING..." : "P2 TURN");
        sEl.innerText = name;
        ssEl.innerText = phase==='PLACING' ? "Deploy Unit" : "Move Unit";
    }
    draw();
}

/* --- RENDERER --- */
const canvas = document.getElementById('gameBoard');
const ctx = canvas.getContext('2d');
let boardSize=0;

function resize() {
    const p = canvas.parentElement;
    boardSize = p.clientWidth;
    const dpr = window.devicePixelRatio||1;
    canvas.width=boardSize*dpr; canvas.height=boardSize*dpr;
    ctx.scale(dpr,dpr);
    canvas.style.width=boardSize+"px"; canvas.style.height=boardSize+"px";
    draw();
}
window.addEventListener('resize', resize);

function draw() {
    ctx.clearRect(0,0,boardSize,boardSize);
    const s = boardSize;
    
    // Grid
    ctx.strokeStyle = '#2a2a40'; ctx.lineWidth = s*0.01; ctx.lineCap='round';
    ctx.shadowBlur=10; ctx.shadowColor='#4d4d80';
    ctx.beginPath();
    board.forEach(p => {
        adj[p.id].forEach(n => {
            if(n>p.id) {
                ctx.moveTo(rawPoints[p.id].x*s, rawPoints[p.id].y*s);
                ctx.lineTo(rawPoints[n].x*s, rawPoints[n].y*s);
            }
        });
    });
    ctx.stroke(); ctx.shadowBlur=0;

    // Units
    board.forEach(p => {
        const px = rawPoints[p.id].x*s;
        const py = rawPoints[p.id].y*s;
        
        if(p.owner===0) {
            ctx.fillStyle='rgba(255,255,255,0.1)';
            ctx.beginPath(); ctx.arc(px,py,s*0.015,0,Math.PI*2); ctx.fill();
        } else {
            const color = p.owner===1 ? P1_COLOR : P2_COLOR;
            const glow = p.owner===1 ? P1_GLOW : P2_GLOW;
            
            ctx.shadowBlur = 15; ctx.shadowColor = glow;
            ctx.fillStyle = '#000'; ctx.strokeStyle = color; ctx.lineWidth = s*0.008;
            
            ctx.beginPath(); ctx.arc(px,py,s*0.035,0,Math.PI*2); ctx.fill(); ctx.stroke();
            
            ctx.fillStyle = color;
            ctx.beginPath(); ctx.arc(px,py,s*0.015,0,Math.PI*2); ctx.fill();

            if(p.id === selectedId) {
                ctx.strokeStyle = '#ffe600'; ctx.lineWidth = s*0.012;
                ctx.beginPath(); ctx.arc(px,py,s*0.05,0,Math.PI*2); ctx.stroke();
            }
        }
    });
}

// Input Hook
canvas.addEventListener('touchstart', e => { e.preventDefault(); handleInputFromEvent(e.touches[0]); }, {passive:false});
canvas.addEventListener('mousedown', e => handleInputFromEvent(e));

function handleInputFromEvent(e) {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const hit = boardSize*0.08;
    
    for(let i=0; i<24; i++) {
        const px = rawPoints[i].x*boardSize;
        const py = rawPoints[i].y*boardSize;
        if(Math.sqrt((x-px)**2 + (y-py)**2) < hit) { handleInput(i); break; }
    }
}

// Init
resize();
</script>
</body>
</html>
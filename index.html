<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Strategy: Ultimate</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-color: #050510;
            --p1-color: #00f2ff;
            --p1-glow: rgba(0, 242, 255, 0.6);
            --p2-color: #ff0055;
            --p2-glow: rgba(255, 0, 85, 0.6);
        }

        body {
            background-color: var(--bg-color);
            color: white;
            font-family: 'Rajdhani', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            user-select: none;
        }

        /* --- MAIN MENU --- */
        #main-menu {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #050510;
            z-index: 200;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.5s;
        }
        
        h1 { font-family: 'Orbitron'; font-size: 2.5rem; color: #fff; text-shadow: 0 0 20px rgba(255,255,255,0.5); margin-bottom: 40px; text-align: center; }

        .menu-btn {
            background: transparent;
            border: 2px solid var(--p1-color);
            color: var(--p1-color);
            padding: 15px 40px;
            margin: 10px;
            font-family: 'Orbitron';
            font-size: 1.2rem;
            cursor: pointer;
            width: 250px;
            text-align: center;
            transition: 0.3s;
            box-shadow: 0 0 15px var(--p1-glow);
        }
        .menu-btn:hover { background: var(--p1-color); color: #000; }
        .menu-btn.secondary { border-color: var(--p2-color); color: var(--p2-color); box-shadow: 0 0 15px var(--p2-glow); }
        .menu-btn.secondary:hover { background: var(--p2-color); color: #000; }

        /* --- FLIP & TARGET POPUP --- */
        #action-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 100;
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            backdrop-filter: blur(8px);
        }

        .coin {
            width: 140px; height: 140px;
            border-radius: 50%;
            background: #222;
            border: 6px solid #fff;
            display: flex; justify-content: center; align-items: center;
            font-size: 2rem; font-family: 'Orbitron';
            box-shadow: 0 0 50px rgba(255,255,255,0.2);
            cursor: pointer;
            transition: transform 0.5s;
        }

        .coin.flip { animation: spinCoin 0.5s infinite linear; }
        @keyframes spinCoin { 0% { transform: rotateY(0deg); } 100% { transform: rotateY(360deg); } }
        .coin.win { border-color: #0f0; color: #0f0; box-shadow: 0 0 50px #0f0; background: #002200; }
        .coin.lose { border-color: #f00; color: #f00; box-shadow: 0 0 50px #f00; background: #220000; }

        .msg-box { margin-top: 30px; font-size: 1.5rem; text-align: center; font-family: 'Orbitron'; letter-spacing: 2px; }

        /* --- GAME BOARD --- */
        .game-container {
            width: 95%; max-width: 500px;
            aspect-ratio: 1 / 1;
            margin-top: 20px;
            position: relative;
        }

        canvas {
            width: 100%; height: 100%;
            background: radial-gradient(circle, #1a1a2e, #000);
            border-radius: 12px;
            border: 1px solid #333;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
        }

        .targeting { cursor: crosshair !important; }

        /* --- HUD --- */
        .hud {
            position: absolute; bottom: 0; width: 100%;
            background: rgba(20, 20, 30, 0.95);
            padding: 20px;
            border-top: 2px solid #333;
            text-align: center;
            border-radius: 20px 20px 0 0;
        }
        .status { font-size: 1.6rem; font-weight: bold; font-family: 'Orbitron'; margin-bottom: 5px; }
        .sub-status { font-size: 1rem; opacity: 0.7; }
        
        .p1-turn { color: var(--p1-color); text-shadow: 0 0 15px var(--p1-glow); }
        .p2-turn { color: var(--p2-color); text-shadow: 0 0 15px var(--p2-glow); }
        .kill-mode { color: #ffe600; text-shadow: 0 0 20px #ffe600; animation: pulse 0.8s infinite; }
        
        @keyframes pulse { 50% { opacity: 0.5; } }

    </style>
</head>
<body>

    <div id="main-menu">
        <h1>NEON STRATEGY</h1>
        <button class="menu-btn" onclick="startGame('PVP')">PLAYER vs PLAYER</button>
        <button class="menu-btn secondary" onclick="startGame('PVC')">PLAYER vs CPU</button>
    </div>

    <div id="action-overlay">
        <div id="coin-visual" class="coin" onclick="startFlip()">FLIP</div>
        <div id="overlay-text" class="msg-box">TRAPPED!<br><span style="font-size:1rem; color:#aaa">Tap Coin to break free</span></div>
    </div>

    <div class="game-container">
        <canvas id="gameBoard"></canvas>
    </div>

    <div class="hud">
        <div id="status" class="status p1-turn">YOUR TURN</div>
        <div id="sub-status" class="sub-status">Place your unit</div>
        <button onclick="location.reload()" style="margin-top:15px; background:none; border:1px solid #555; color:#aaa; padding:8px 20px;">MAIN MENU</button>
    </div>

<script>
// --- CONFIG ---
const P1_COLOR = '#00f2ff';
const P2_COLOR = '#ff0055';

// --- GAME STATE ---
let gameMode = 'PVC'; // 'PVP' or 'PVC'
let turn = 1; // 1 = P1, 2 = P2/AI
let phase = 'PLACING'; // PLACING, MOVING, REMOVING, TRAPPED, GAME_OVER
let board = [];
let p1Left = 12, p2Left = 12;
let p1Board = 0, p2Board = 0;
let selectedId = -1;

// 24 Points Layout
const rawPoints = [
    {x:0.1,y:0.1},{x:0.5,y:0.1},{x:0.9,y:0.1}, {x:0.9,y:0.5},{x:0.9,y:0.9},{x:0.5,y:0.9}, {x:0.1,y:0.9},{x:0.1,y:0.5},
    {x:0.25,y:0.25},{x:0.5,y:0.25},{x:0.75,y:0.25}, {x:0.75,y:0.5},{x:0.75,y:0.75},{x:0.5,y:0.75}, {x:0.25,y:0.75},{x:0.25,y:0.5},
    {x:0.4,y:0.4},{x:0.5,y:0.4},{x:0.6,y:0.4}, {x:0.6,y:0.5},{x:0.6,y:0.6},{x:0.5,y:0.6}, {x:0.4,y:0.6},{x:0.4,y:0.5}
];
const adj = [
    [1,7,8],[0,2,9],[1,3,10],[2,4,11],[3,5,12],[4,6,13],[5,7,14],[0,6,15],
    [0,9,15,16],[1,8,10,17],[2,9,11,18],[3,10,12,19],[4,11,13,20],[5,12,14,21],[6,13,15,22],[7,8,14,23],
    [8,17,23],[9,16,18],[10,17,19],[11,18,20],[12,19,21],[13,20,22],[14,21,23],[15,16,22]
];
const mills = [
    [0,1,2],[2,3,4],[4,5,6],[6,7,0], [8,9,10],[10,11,12],[12,13,14],[14,15,8],
    [16,17,18],[18,19,20],[20,21,22],[22,23,16], [1,9,17],[3,11,19],[5,13,21],[7,15,23],
    [0,8,16],[2,10,18],[4,12,20],[6,14,22]
];

function startGame(mode) {
    gameMode = mode;
    document.getElementById('main-menu').style.display = 'none';
    init();
}

function init() {
    board = rawPoints.map((p,i)=>({id:i, owner:0}));
    turn = 1; phase = 'PLACING';
    p1Left=12; p2Left=12; p1Board=0; p2Board=0;
    selectedId=-1;
    resize(); updateUI();
}

// --- LOGIC ---
function handleClick(idx) {
    // If PvC, ignore clicks during AI turn
    if(gameMode === 'PVC' && turn === 2) return;
    if(phase === 'TRAPPED' || phase === 'GAME_OVER') return;

    if(phase === 'PLACING') {
        if(board[idx].owner !== 0) return;
        move(idx, turn, 'PLACE');
    } 
    else if(phase === 'MOVING') {
        if(board[idx].owner === turn) { selectedId = idx; updateUI(); }
        else if(selectedId !== -1 && board[idx].owner === 0 && adj[selectedId].includes(idx)) {
            move(idx, turn, 'MOVE', selectedId);
        }
    }
    else if(phase === 'REMOVING') {
        const enemy = turn === 1 ? 2 : 1;
        // Only target enemy
        if(board[idx].owner === enemy) {
            if(isProtected(idx, enemy)) { alert("Cannot target protected unit!"); return; }
            kill(idx, enemy);
        }
    }
}

function move(to, ply, type, from) {
    board[to].owner = ply;
    if(type==='PLACE') { if(ply===1) p1Left--; else p2Left--; if(ply===1) p1Board++; else p2Board++; }
    if(type==='MOVE') { board[from].owner = 0; selectedId = -1; }

    if(checkMill(to, ply)) {
        phase = 'REMOVING';
        if(gameMode === 'PVC' && ply === 2) setTimeout(aiKill, 800);
        else updateUI(true, "TARGET LOCKED", "Tap enemy unit to destroy");
    } else {
        endTurn();
    }
}

function kill(idx, owner) {
    board[idx].owner = 0;
    if(owner===2) p2Board--; else p1Board--;
    
    // Check Win
    if(p1Left===0 && p2Left===0) {
        if(p2Board < 3) { gameOver(1); return; }
        if(p1Board < 3) { gameOver(2); return; }
    }
    
    phase = (p1Left>0 || p2Left>0) ? 'PLACING' : 'MOVING';
    endTurn();
}

function endTurn() {
    if(phase === 'GAME_OVER') return;
    turn = (turn===1) ? 2 : 1;
    
    // TRAP CHECK
    if(phase === 'MOVING' && countMoves(turn) === 0) {
        phase = 'TRAPPED';
        showPopup(turn);
        return;
    }

    updateUI();
    
    // Trigger AI if needed
    if(gameMode === 'PVC' && turn === 2) {
        setTimeout(aiTurn, 800);
    }
}

// --- COIN FLIP POPUP ---
function showPopup(who) {
    const overlay = document.getElementById('action-overlay');
    const txt = document.getElementById('overlay-text');
    const coin = document.getElementById('coin-visual');
    
    overlay.style.display = 'flex';
    coin.className = 'coin'; 
    coin.innerText = "FLIP";
    
    let canInteract = true;

    // Logic: In PvC, AI (P2) is automated. In PvP, humans click for themselves.
    if(gameMode === 'PVC' && who === 2) {
        // AI Trapped
        txt.innerHTML = "CPU TRAPPED!<br><span style='font-size:1rem; color:#aaa'>CPU is attempting override...</span>";
        canInteract = false;
        setTimeout(startFlip, 1500);
    } else {
        // Human Trapped (P1 or P2 in PvP)
        const pName = (who === 1) ? "PLAYER 1" : "PLAYER 2";
        const col = (who === 1) ? P1_COLOR : P2_COLOR;
        txt.innerHTML = `<span style="color:${col}">${pName} TRAPPED!</span><br><span style='font-size:1rem; color:#aaa'>Flip to break the lock</span>`;
    }

    if(canInteract) coin.onclick = startFlip;
    else coin.onclick = null;
}

function startFlip() {
    const coin = document.getElementById('coin-visual');
    const txt = document.getElementById('overlay-text');
    
    coin.className = 'coin flip';
    coin.innerText = "";
    
    setTimeout(() => {
        const win = Math.random() > 0.5;
        const player = turn; 
        
        coin.className = win ? 'coin win' : 'coin lose';
        coin.innerText = win ? "WIN" : "FAIL";
        
        if(win) {
            txt.innerHTML = "SUCCESS!<br><span style='font-size:1rem; color:#0f0'>ACCESSING TARGETING SYSTEM...</span>";
            setTimeout(() => {
                document.getElementById('action-overlay').style.display = 'none';
                phase = 'REMOVING';
                
                // If AI won logic, trigger AI kill
                if(gameMode === 'PVC' && player === 2) aiKill();
                else updateUI(true, "SELECT TARGET", "Tap any enemy unit");

            }, 1500);
        } else {
            txt.innerHTML = "FAILURE<br><span style='font-size:1rem; color:#f00'>SYSTEM LOCKDOWN</span>";
            setTimeout(() => gameOver(player===1?2:1), 1500);
        }
    }, 1500);
}

// --- AI (CPU) LOGIC ---
function aiTurn() {
    if(phase === 'TRAPPED') return; 

    // Simple AI: Check moves
    let moves = [];
    if(phase==='PLACING') {
        board.forEach(p=>{if(p.owner===0)moves.push({to:p.id})});
    } else {
        board.forEach(p=>{
            if(p.owner===2) adj[p.id].forEach(n=>{if(board[n].owner===0)moves.push({from:p.id,to:n})});
        });
    }
    
    if(moves.length > 0) {
        // Try to find a mill
        let best = moves[Math.floor(Math.random() * moves.length)]; // Default random
        for(let m of moves) {
            let prev = board[m.to].owner;
            board[m.to].owner = 2; // Sim
            if(m.from!==undefined) board[m.from].owner=0;
            if(checkMill(m.to, 2)) { best = m; board[m.to].owner=prev; if(m.from!==undefined)board[m.from].owner=2; break; }
            board[m.to].owner=prev; if(m.from!==undefined)board[m.from].owner=2;
        }
        move(best.to, 2, phase==='PLACING'?'PLACE':'MOVE', best.from);
    }
}

function aiKill() {
    // AI kills random unprotected
    let targets = board.filter(p=>p.owner===1 && !isProtected(p.id, 1));
    if(targets.length > 0) kill(targets[0].id, 1);
    else { phase='MOVING'; endTurn(); } 
}

// --- HELPERS ---
function checkMill(idx, ply) {
    for(let m of mills) if(m.includes(idx) && board[m[0]].owner===ply && board[m[1]].owner===ply && board[m[2]].owner===ply) return true;
    return false;
}
function isProtected(idx, ply) {
    if(!checkMill(idx, ply)) return false;
    let all = board.filter(p=>p.owner===ply);
    return !all.every(p=>checkMill(p.id, ply));
}
function countMoves(ply) {
    let c = 0;
    board.filter(p=>p.owner===ply).forEach(p=> {
        adj[p.id].forEach(n=>{if(board[n].owner===0)c++});
    });
    return c;
}
function gameOver(winner) {
    document.getElementById('action-overlay').style.display='none';
    phase = 'GAME_OVER';
    let wName = (winner===1) ? "PLAYER 1" : (gameMode==='PVC'?"CPU":"PLAYER 2");
    updateUI(true, wName + " WINS!", "Opponent Eliminated");
}

// --- RENDER ---
const canvas = document.getElementById('gameBoard');
const ctx = canvas.getContext('2d');
let bs = 0;

function resize() {
    bs = canvas.parentElement.clientWidth;
    canvas.width = bs; canvas.height = bs;
    draw();
}
window.onresize = resize;

function draw() {
    ctx.clearRect(0,0,bs,bs);
    
    // Lines
    ctx.strokeStyle = '#333'; ctx.lineWidth = 4; ctx.beginPath();
    board.forEach(p => adj[p.id].forEach(n => { if(n>p.id) {
        ctx.moveTo(rawPoints[p.id].x*bs, rawPoints[p.id].y*bs);
        ctx.lineTo(rawPoints[n].x*bs, rawPoints[n].y*bs);
    }}));
    ctx.stroke();

    // Points
    board.forEach(p => {
        let x = rawPoints[p.id].x*bs, y = rawPoints[p.id].y*bs;
        if(p.owner===0) {
            ctx.fillStyle='#222'; ctx.beginPath(); ctx.arc(x,y,6,0,Math.PI*2); ctx.fill();
        } else {
            let col = p.owner===1 ? P1_COLOR : P2_COLOR;
            ctx.fillStyle = col; ctx.shadowBlur=15; ctx.shadowColor=col;
            ctx.beginPath(); ctx.arc(x,y,15,0,Math.PI*2); ctx.fill(); ctx.shadowBlur=0;
            
            // Highlight Targetable enemies in Kill Mode
            if(phase === 'REMOVING') {
                const enemy = turn === 1 ? 2 : 1;
                if(p.owner === enemy && !isProtected(p.id, enemy)) {
                    ctx.strokeStyle = '#fff'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(x,y,20,0,Math.PI*2); ctx.stroke();
                }
            }
            // Selection Ring
            if(p.id===selectedId) {
                ctx.strokeStyle = '#fff'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(x,y,22,0,Math.PI*2); ctx.stroke();
            }
        }
    });
}

function updateUI(alert, t, sub) {
    const s = document.getElementById('status');
    const ss = document.getElementById('sub-status');
    const cvs = document.getElementById('gameBoard');
    
    if(t) {
        s.innerText = t; ss.innerText = sub;
        s.className = alert ? "status kill-mode" : (turn===1?"status p1-turn":"status p2-turn");
    } else {
        let pName = (turn===1) ? "PLAYER 1" : (gameMode==='PVC'?"CPU":"PLAYER 2");
        s.innerText = pName + " TURN";
        s.className = turn===1 ? "status p1-turn" : "status p2-turn";
        ss.innerText = phase==='PLACING' ? "Place Unit" : "Move Unit";
    }
    
    if(phase === 'REMOVING' && turn === 1) cvs.className = "targeting";
    else cvs.className = "";
    
    draw();
}

// Input
canvas.addEventListener('mousedown', e => input(e.clientX, e.clientY));
canvas.addEventListener('touchstart', e => { e.preventDefault(); input(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});

function input(cx, cy) {
    let r = canvas.getBoundingClientRect();
    let x = cx-r.left, y = cy-r.top;
    for(let i=0; i<24; i++) {
        let px = rawPoints[i].x*bs, py = rawPoints[i].y*bs;
        if(Math.hypot(x-px, y-py) < 30) { handleClick(i); break; }
    }
}
</script>
</body>
</html>
